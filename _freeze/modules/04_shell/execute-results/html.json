{
  "hash": "743f9c55595b46cb4df8fc2888d42b8e",
  "result": {
    "markdown": "---\ntitle: \"The Unix Shell - Part I\"\nsubtitle: \"And an introduction to FASTQ and FASTA files\"\npagetitle: \"Unix Shell\"\nhighlight-style: github\nnumber-sections: true\nengine: knitr\nauthor: Jelmer Poelstra\ndate: 2023-07-28\n---\n\n::: {.cell}\n\n:::\n\n\n-----\n\n<br>\n\n## Introduction\n\nMany of the things you typically do by pointing and clicking can alternatively\nbe done by typing commands.\nThe Unix shell allows you to interact with computers via commands.\nIt is natively available through a Terminal app in computers with Unix-like\noperating systems like Linux (on which OSC runs) or MacOS,\nand can also be installed on Windows computers with relatively\nlittle trouble these days\n(see the [SSH reference page on this website](../info/osc_ssh.qmd)).\n\nWorking effectively on a remote supercomputer tends to simply _require_ using a\ncommand line interface.\nBut there are more **advantages to doing command line computing**\nthan just allowing you to work on a supercomputer, such as:\n\n  - Working efficiently with large files\n  - Achieving reproducibility in research\n  - Perform general computing tasks more efficiently, once you get the hang of it\n  - Making it much easier to repeat similar tasks across files, samples,\n    and projects, with the possibility of true automation\n  - For bioinformatics, being able to use command-line programs directly\n    without having to depend on \"GUI wrappers\" written by third parties,\n    that often cost money and lag behind in functionality\n\nIn these sessions, **we'll use a Unix shell at OSC inside VS Code**.\nFot this sessio,\nI will assume you still have an active VS Code session as setup in the\n[previous one](02_osc.qmd), have VS Code located at `/fs/ess/PAS0471`,\nand with an open Terminal &mdash; if not, see the instructions in the dropdown\nbox right below.\n\n[^1]: But just for reference, there are other ways of accessing a Unix shell at OSC:\nfor example, you can also get Shell access through the \"Clusters\" menu\nin OSC OnDemand,\nor you could connect your local Unix shell to OSC through SSH\n(again, [see this reference page](../info/osc_ssh.qmd)).\n\n:::{.callout-tip collapse=\"true\"}\n## Starting VS Code at OSC - with a Terminal\n1. Log in to OSC's OnDemand portal at <https://ondemand.osc.edu>.\n2. In the blue top bar, select `Interactive Apps`\n   and then near the bottom of the dropdown menu, click `Code Server`.\n3. In the form that appears on a new page:\n   - Select an appropriate OSC project (here: `PAS0471`)\n   - For this session, select `/fs/ess/PAS0471` as the starting directory\n   - Make sure that `Number of hours` is at least `2`\n   - Click `Launch`.\n4. On the next page, once the top bar of the box has turned green\n   and says `Runnning`, click `Connect to VS Code`.\n\n<figure><p align=\"center\"><img src=img/osc-code-launch_ed.png width=\"80%\"></p></figure>\n\n5. Open a Terminal by clicking\n   &nbsp; {{< fa bars >}} &nbsp; => `Terminal` => `New Terminal`.\n   (Or use one of the keyboard shortcuts:\n   <kbd>Ctrl</kbd>+<kbd>\\`</kbd> (backtick) or\n   <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>C</kbd>.)\n6. Type `pwd` to check where you are.\n   If you are not in `/fs/ess/PAS0471`,\n   click `Open folder...` in the `Welcome` tab,\n   or &nbsp; {{< fa bars >}} &nbsp; => &nbsp; `File` &nbsp; => &nbsp; `Open Folder`,\n   then type/select `/fs/ess/PAS0471` and press Ok.\n\n:::\n\n::: {.callout-note}\n#### Some Terminology\n\nWe're going to focus on the practice of doing command line computing here,\nand not get too bogged down in terminology,\nbut let's highlight a few interrelated terms you're likely to run across:\n\n  - **Command Line** &mdash; the most general term, an interface where you type commands\n  - **Terminal** &mdash; the program/app/window that can run a Unix shell \n  - **Shell** &mdash; a command line interface to your computer\n  - **Unix Shell** &mdash; the types of shells on Unix family (Linux + Mac) computers \n  - **Bash** &mdash; the specific Unix shell language that is most common on Unix computers\n  - **Bash Shell** &mdash; a Unix shell that uses the Bash language\n  \nWhile it might not fly for a computer science class,\nfor day-to-day computing/bioinformatics,\nyou'll probably hear all these terms used somewhat interchangably.\nBasically, we're talking about the process of interacting with your computer by\ngiving it commands as opposed to the point-and-click way you're likely more familiar with.\n\n:::\n\n<br>\n\n## First steps\n\n### The prompt\n\nInside your terminal, the \"prompt\" indicates that the shell is ready for a command.\nWhat is shown exactly varies a bit across shells and can also be customized,\nbut our prompts at OSC should show the following:\n\n``` {.bash-in-nocolor}\n[<username>@<node-name> <working-dir>]$\n```\n\nFor example:\n\n``` {.bash-in-nocolor}\n[jelmer@p0080 PAS0471]$ \n```\n\nWe type our commands after the dollar sign,\nand then press <kbd>Enter</kbd> to execute the command.\nWhen the command has finished executing,\nwe'll get our prompt back and can type a new command.\n\n::: {.callout-tip}\n#### How shell code is presented on this website\nThe pale gray boxes like the ones shown above will be used to represent your\ncommand prompt, or rather, to show the command line expressions that you\nwill type.\n\nIn upcoming boxes, the prompt itself (`[...]$`) will not be shown,\nbut only the command line expressions that you type.\nThis is to save space and also because if we omit the prompt,\nyou will be able to directly copy and paste commands from the website to your shell. \n\nAlso, in a notation like `<username>`,\nthe `< >` are there to indicate this is not an actual, functional example,\nbut a descriptive generalization, and should not be part of the final code.\nIn this case, then, it should be replaced merely by a username (e.g. `jelmer`),\nand _not_ by `<jelmer>`, as you can see in the example with the prompt above.\n:::\n\n<br>\n\n### A few simple commands: `date`, `whoami`, `pwd`\n\nThe Unix shell comes with hundreds of commands.\nLet's start with a few simple ones.\n\nThe `date` command prints the current date and time:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ndate\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\nFri Jul 28 09:29:41 EDT 2023\n```\n:::\n:::\n\n\n::: {.callout-tip}\n#### Copying code from the website, and code output\nWhen you hover your mouse above the top box with the command,\nyou should see a copy icon appear on the far right,\nwhich will copy the command to your clipboard:\nfor longer expressions, this can be handy so you can paste this right into your shell\nand don't have to type.\nGenerally speaking, though, it does help to type the commands yourself!\n\nAlso, the darker gray box below, with italic text,\nis intended to show the _output_ of commands as they are printed to the screen\nin the shell.\n:::\n\nThe `whoami` (who-am-i) command prints your username:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nwhoami\n```\n:::\n\n\n``` {.bash-out}\njelmer\n```\n\nThe `pwd` (Print Working Directory) commands prints the path to the directory\nyou are currently located in:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\npwd\n```\n:::\n\n\n``` {.bash-out}\n/fs/ess/PAS0471\n```\n\nAll 3 commands that we just used provided us with some output.\n_That output was **printed to screen**,\nwhich is the default behavior for nearly every Unix command_.\n\n:::{.callout-note}\n#### Working directories, and paths part I\n\nOn Unix systems,\nall the files on a computer exist within **a single hierarchical system of directories**\n(folders).\nWhen working in the Unix shell, you are always \"in\" one of these directories.\nThe directory you're \"in\" at any given time is referred to as your **working directory**.\n\nIn a **path** (specification of a file or directory location)\nsuch as that output by `pwd`, directories are separated by forward slashes `/`.\n\nA **leading forward slash** in a path indicates the root directory of the computer,\nand as such, the path provided by `pwd` is an _absolute path_ (or: _full path_),\nand not a _relative path_ &mdash; more on that later.\n\nWhile not applicable with `cd`,\nif you _happen to see_ a **trailing forward slash** in a path\n(eg. `/fs/ess/PAS0471/`),\nyou can be sure that the path points to a directory and not a file.\n:::\n\n<br><br>\n\n## `cd` and command actions, defaults, and arguments\n\nIn the above three command line expressions:\n\n- We merely typed the _name of a command and nothing else_\n- The main function of the command was to _provide some information_,\n  which was the output printed to screen\n\nBut many commands perform an **action** other than printing output.\nFor example, the very commonly used command **`cd` (Change Directory)**\nwill, you guessed it,\nchange your working directory.\nAnd as it happens, it has no output at all.\n\nWe start by simply typing `cd`:\n\n```bash\ncd\n```\n\nDid anything happen? Maybe it failed?\nYou might expect a command like `cd` to _report_ what it did, but it does not.\nAs a general rule for Unix commands that perform actions,\nand one that also applies to `cd`:\n**if the command does not print any output, this means it was successful.**\n\nSo where did we change our working directory to, given that we did not tell\n`cd` where to move?\n\n:::{.exercise}\n#### Your Turn: Check what directory we moved to {-}\n<details><summary>Solution (click here)</summary>\n```bash\npwd\n```\n```{.bash-out}\n/users/PAS0471/jelmer\n```\nIt appears that we moved to our home directory!\n(Remember, we were in the project directory `/fs/ess/PAS0471`.)\n</details>\n:::\n\nFrom this, we can infer that the **default behavior** of `cd`,\ni.e. when it is not given any additional information,\nis to move to a user's home directory.\nThis is actually a nice trick to remember!\n\nNow, let's move to another directory, one that contains some files we can explore\nto learn our next few commands.\nWe can do so by specifying the _path_ to that directory after the `cd` command\n(make sure to leave a space after `cd`!):\n\n```bash\ncd demo/202307_rnaseq/\n```\n\n```bash\npwd\n```\n```{.bash-out}\n/fs/ess/PAS0471/demo/202307_rnaseq\n```\n\nIn more abstract terms, what we did above was to provide `cd` with an **argument**\n(namely, the path to the dir to move to).\nArguments generally tell commands what file or directory to operate on,\nand come at the end of a command line expression.\nThere should always be a space between the command and its argument(s)!\n\n::: {.callout-note collapse=\"true\"}\n#### Tab completion!! (Click here to learn more)\n\n- After typing `/fs/e`, press the <kbd>Tab</kbd> key!\n\n    ```{.bash-out-solo}\n    /fs/ess/\n    ```\n\n- After typing `/fs/ess/P`, press the <kbd>Tab</kbd> key.\n  Nothing will happen, so now press it quickly twice in succession.\n  \n  ```{.bash-out-solo}\n  Display all 709 possibilities? (y or n)\n  ```\n\n  Type `n`. Why does this happen?\n\n- After typing `/fs/ess/PAS04`, press the <kbd>Tab</kbd> key twice quickly in\n  succession (\"Tab-tab\").\n\n  ```{.bash-out-solo}\n  PAS0400/ PAS0409/ PAS0418/ PAS0439/ PAS0453/ PAS0456/ PAS0457/ PAS0460/ PAS0471/ PAS0472/ PAS0498/ \n  ```\n\n- After typing `/fs/ess/PAS0471/demo/2`, press the <kbd>Tab</kbd> key!\n\n  ```{.bash-out-solo}\n  /fs/ess/PAS0471/demo/202307_rnaseq/\n  ```\n\nThe tab completion feature will check for files/dirs present in the location\nyou're at, and based on the characters you've typed so for, complete the path\nas far as it can.\n\nSometimes it can't move forward at all because there are multiple files or dirs\nthat have the same next character.\nPressing \"Tab-tab\" will then show your options,\nthough in unusual circumstances like one above, there are so many that it asks\nfor confirmation. Then, it's better to just keep typing assuming that you know\nwhere you want to go.\n\nBut in general, Tab completion is an incredibly useful feature that you should\ntry to get accustomed to using right away!\n:::\n\nAs we've seen, then, `cd` gives no output when it succesfully changed the\nworking directory (\"silence is golden\"!).\nBut let's also see what happens when it does not succeed &mdash;\nit gives the following error:\n\n```bash\ncd /fs/Ess/PAS0471\n```\n``` {.bash-out}\nbash: cd: /fs/Ess/PAS0471: No such file or directory\n```\n\n:::{.exercise}\n#### Your Turn: What was the problem with the path we specified? {-}\n<details><summary>Solutions (click here)</summary>\nWe used a capital E in `/Ess/` &mdash; this should have been `/ess/`.\n\nIn other words, paths (dir and file specifications) are **case-sensitive**\non Unix systems!\n</details>\n:::\n\n**In summary**, in this section we've learned that:\n\n- The **`cd` command** can be used to change your working directory\n- Unix commands like `cd` that perform **actions**\n  will by default only print output to screen when something goes wrong (i.e., errors)\n- Commands can have _default behaviours_ when they are not given specific directions\n- We can give commands like `cd` **arguments** to tell them what to do / operate on.\n\nNext, we'll learn about _options_ to commands in the context of the `ls` command.\n\n<br>\n\n## `ls` and command _options_\n\n### The default behavior of `ls`\n\nThe `ls` command, short for \"list\",\nis a quite flexible command to list files and directories:\n\n```bash\nls\n```\n``` {.bash-out}\ndata  metadata  README.md\n```\n\n(You should still be in `/fs/ess/PAS0471/demo/202307_rnaseq`.\nIf not, `cd` there first.)\n\n:::{.callout-tip}\n#### `ls` output colors\nUnfortunately, the `ls` output shown above does not show the different colors\nyou should see in your shell &mdash; here are some of the most common ones:\n\n- Entries in <span style=\"color: #0328fc\">blue</span> are directories\n  (like `data` and `metadata` above)\n- Entries in black are regular files (like `README.md` above)\n- Entries in <span style=\"color: #d92118\">red</span> are compressed files\n  (we'll see an example soon).\n:::\n\nThe default behavior of `ls` includes that it will:\n\n- List files and dirs inside our current working directory,\n  and do so _non-recursively_: it won't list files inside those directories, and so on.\n- Show as many files and dirs as it can on one line, each separated by a few spaces\n- Sort files and dirs alphabetically (and not separately so)\n- Not show any other details about the files, such as their size, owner, and so on.\n\nAll of this, and more, can be changed by providing `ls` with **options** and/or\n**arguments**.\n\n### First, more on arguments\n\nLet's start with an _argument_, since we're familiar with those in the context of `cd`.\nAny argument to `ls` should be **a path to operate on**.\nFor example, if we wanted to see what's inside that mysterious `data` dir,\nwe could type:\n\n```bash\nls data\n```\n```{.bash-out}\nfastq\n```\n\nWell, that's not much information, just another dir &mdash;\nso let's look inside that:\n\n```bash\nls data/fastq\n```\n```{.bash-out}\nASPC1_A178V_R1.fastq.gz  ASPC1_G31V_R2.fastq.gz      Miapaca2_G31V_R1.fastq.gz\nASPC1_A178V_R2.fastq.gz  Miapaca2_A178V_R1.fastq.gz  Miapaca2_G31V_R2.fastq.gz\nASPC1_G31V_R1.fastq.gz   Miapaca2_A178V_R2.fastq.gz\n```\n\nAh, there are some gzipped FASTQ files!\nThese contain our sequence data, and we'll go and explore them in a bit.\n\nWe can also provide `ls` with **multiple arguments** &mdash;\nand it will nicely tell us which files are in each of the dirs we specified:\n\n```bash\nls data metadata\n```\n\n```{.bash-out}\ndata:\nfastq\n\nmetadata:\nmeta.tsv\n```\n\nMany Unix commands will accept multiple arguments (files or dirs to operate on),\nwhich can be very useful.\n\n### Options\n\nFinally, we'll turn to options.\nWhereas, in general, _arguments_ tell a command what to operate on,\n_options_ (also called \"flags\") will modify its behavior.\n\nFor example, we can call `ls` with the **option `-l`**\n(a dash followed by a lowercase L):\n\n```bash\nls -l \n```\n\n```{.bash-out}\ntotal 17\ndrwxr-xr-x 3 jelmer PAS0471 4096 Jul 27 11:53 data\ndrwxr-xr-x 2 jelmer PAS0471 4096 Jul 27 11:54 metadata\n-rw-r--r-- 1 jelmer PAS0471  963 Jul 27 16:48 README.md\n```\n\nNotice that it lists the same three items as our first `ls` call above,\nbut this time, they're printed in a different format:\none item per line, with lots of additional information included.\nFor example, the date and time is that when the file was last modified\n(we'll go a bit more into the info in the different columns below).\n\nLet's add another option, `-h`:\n\n```bash\nls -l -h\n```\n\n```{.bash-out}\ntotal 17K\ndrwxr-xr-x 3 jelmer PAS0471 4.0K Jul 27 11:53 data\ndrwxr-xr-x 2 jelmer PAS0471 4.0K Jul 27 11:54 metadata\n-rw-r--r-- 1 jelmer PAS0471  964 Jul 27 17:48 README.md\n```\n\nCan you pick out what `-h` did to modify the output?\nNote the difference in the format of the column reporting the sizes of the items listed.\n\nOptions can be pasted together as follows:\n\n```bash\nls -lh   # Output not shown, same as above\n```\n\n\nThe figure below shows what information is shown in each of the columns\n(but note that it shows a different listing of files,\nand uses the new-to-us `-a` option, short for \"all\", to also show \"hidden files\"):\n\n<p align=\"left\"><img src=img/long-ls.png width=\"80%\"></p>\n\n<br>\n\nFinally, we can **combine options and arguments**,\nand let's do so take a closer look at our dir with FASTQ files &mdash;\nnow the `-h` option is especially useful because it makes it easy to see that the files\nvary between 4.1 MB and 5.3 MB in size:\n\n```bash\nls -lh data/fastq\n```\n\n``` {.bash-out}\ntotal 38M\n-rw-r--r-- 1 jelmer PAS0471 4.1M Jul 27 11:53 ASPC1_A178V_R1.fastq.gz\n-rw-r--r-- 1 jelmer PAS0471 4.2M Jul 27 11:53 ASPC1_A178V_R2.fastq.gz\n-rw-r--r-- 1 jelmer PAS0471 4.1M Jul 27 11:53 ASPC1_G31V_R1.fastq.gz\n-rw-r--r-- 1 jelmer PAS0471 4.3M Jul 27 11:53 ASPC1_G31V_R2.fastq.gz\n-rw-r--r-- 1 jelmer PAS0471 5.1M Jul 27 11:53 Miapaca2_A178V_R1.fastq.gz\n-rw-r--r-- 1 jelmer PAS0471 5.3M Jul 27 11:53 Miapaca2_A178V_R2.fastq.gz\n-rw-r--r-- 1 jelmer PAS0471 5.1M Jul 27 11:53 Miapaca2_G31V_R1.fastq.gz\n-rw-r--r-- 1 jelmer PAS0471 5.3M Jul 27 11:53 Miapaca2_G31V_R2.fastq.gz\n```\n\n**In summary**, in this section we have learned that:\n\n- The `ls` command lists files (by default without additional info and non-recursively)\n- Using _arguments_, we tell `ls` (and other commands) what to operate on\n- Using _options_, we can make `ls` show us the resulting dirs and files in different ways.\n  The ones we've seen so far act as \"on/off switches\",\n  and this is common among Unix commands (but we'll see other kinds of options too!).\n\n::: {.callout-note}\n#### More on arguments and options\n\nAbove, we described the general _functional differences between options and arguments_.\nBut they are really defined by the differences in the associated syntax:\n\n- **Arguments** come at the _end_ of the command-line expression (i.e., after options)\n  and are not preceded by a dash or any other pointer.\n  They are typically names of files or dirs, but can be other things too.  \n\n- **Options** are preceded by at least one dash (`-`).\n  With Unix commands, we'll most commonly see \"short options\"\n  like `-h` (as in `ls -h`): single-dash then single-letter.\n  But many options also have \"long option\" counterparts\n  (and some only exist as long options),\n  such as the `--human-readable` counterpart to `-h`:\n  i.e. double-dash, then a word.\n\n**Short options** are very terse but still often preferred with Unix commands,\nbecause they are shorter to type,\nand you might use, say, `ls -lh` dozens if not hundreds of time a day if you work\nin the Unix shell a lot.\n\nConversely, with bioinformatics programs,\nI would recommend to mostly use **long options** whenever they are available,\nso that it's easier you to remember what you did with that option,\nand more likely to be immediately understood by anyone reading the code\n(since an option name like `--human-readable` is mean to be descriptive).\n\n**Some options are not on/off switches and accept values**\n(confusingly, these values can also be called \"arguments\" to options).\nFor example, the `--color` option to `ls` determines how it colorized its output:\nthere is `ls --color=never` &mdash; versus, among other possibilities,\n`ls --color=always`.\n\nWe'll see _a lot_ of options that take values when running bioinformatics\nprograms, such as to set parameters &mdash; for example:\n`trim_galore --quality 30 --length 50` would set a minimum Phred quality score\nthreshold of 30 and a minimum read length threshold of 50 bases for the program\nTrimGalore, which we will later use to quality-trim and adapter-trim FASTQ files.\n:::\n\n::: {.callout-note collapse=\"true\"}\n#### The `tree` command and recursive `ls` (Click to expand)\n\nThe `tree` command lists files _recursively_ (i.e., it will also show us what's\ncontained in the directories in our working directory),\nand does so in a tree-like fashion &mdash;\nthis can be great to quicly get an intuitive overview of files in a dir:\n\n```bash\ntree -C     # The -C option will colorize the output\n```\n<p align=\"left\"><img src=img/tree_output.png width=\"50%\"></p>\n\nAs an aside: if we want to make `ls` list files recursively,\nwe can use the `-R` option:\n\n```bash\nls -R\n```\n```{.bash-out}\n.:\ndata  metadata  README.md\n\n./data:\nfastq\n\n./data/fastq:\nASPC1_A178V_R1.fastq.gz  ASPC1_G31V_R2.fastq.gz      Miapaca2_G31V_R1.fastq.gz\nASPC1_A178V_R2.fastq.gz  Miapaca2_A178V_R1.fastq.gz  Miapaca2_G31V_R2.fastq.gz\nASPC1_G31V_R1.fastq.gz   Miapaca2_A178V_R2.fastq.gz\n\n./metadata:\nmeta.tsv\n```\n\n:::\n\n<br>\n\n## Paths\n\n\"Paths\" are specifications of a location on a computer,\neither of a file or a directory.\n\nWe've talked about the commands `cd` and `ls` which operate on paths,\nand without going into detail about it so far, \nwe've also seen two distinct ways of specifying paths:\n\n- **Absolute (full) paths** always start from the root directory of the computer,\n  which represented by a _**leading `/`**_, such as in `/fs/scratch/PAS0471/`.\n  Absolute paths are like GPS coordinates to specify a geographic location on earth:\n  they will provide location information regardless of where we are ourselves.\n\n- **Relative paths** start from your current location (working directory).\n  When we typed `ls data` earlier,\n  we indicated that we wanted to show the contents of the\n  `data` directory located inside our current working directory &mdash;\n  that probably seemed intuitive.\n  But be aware that the shell would look absolutely nowhere else for that dir\n  than in our current working directory.\n  Relative paths are more like directions to a location that say things like\n  \"turn left\" &mdash; these instructions depend on our current location.\n\nAbsolute paths may seem preferable because they will work regardless of where\nyou are located, **but**:\n\n- They are often a bit more typing than we need (or want) to do.\n- While context-specific, a much more important disadvantage of absolute paths\n  is that they can only be expected to work on one specific computer,\n  and are guaranteed not to work after you move files around.\n\n:::{.exercise}\n#### How might relative dirs work on other computers or after moving files? {-}\n<details><summary>Solution (click here)</summary>\n\nSay that Lucie has a directory for a research project, `/fs/ess/PAS0471/lucie/rnaseq1`,\nwith lots of dirs and files contained in it.\nIn all her code, she specify paths relative to that top-level project directory.\n\nThen, she share that entire directory with someone else, copying it off OSC.\nIf her collaborator goes wherever _they_ now have that directory stored,\ne.g. `/home/philip/lucie_collab/rnaseq1`, and then start using Lucie's code\nwith relative paths, **they would still work**.\n\nSimilarly, if Lucie moves her dir to `/fs/scratch/PAS0805/lucie/rnaseq1`,\nall her code with relative paths **would still work as well**.\n\nThis is something we'll come back to later when talking about reproducibity.\n</details>\n:::\n\n<br>\n\n### Moving \"up\" when using relative paths\n\nThere are a couple of \"shortcuts\" available for relative paths.\nFirst of all, `.` just means the current working directory.\nTherefore, for instance,\n`ls ./data` is functionally the same as `ls data`,\nand just a more explicit way of saying that the `data` dir is located in your\ncurrent working dir (this syntax is occasionally actually useful).\n\nMore usefully for our purposes here, **`..` means one directory (one level) up**\nin the directory hierarchy, with \"up\" meaning towards the root directory\n(I guess the directory tree is best visualized upside down!):\n\n```bash\nls ..               # One level up, listing /fs/ess/PAS0471/demo\n```\n```{.bash-out}\n202307_rnaseq\n```\n\nThis pattern can be continued all the way to the root,\nso `../..` would list the files too levels up:\n\n```bash\nls ../..            # Two levels up, listing /fs/ess/PAS0471\n```\n```{.bash-out}\naarevalo       conroy      frederico       Nisha     osu8947              ross\nacl            containers  hsiangyin       osu10028  osu9207              Saranga\nAlmond_Genome  danraywill  jelmer          osu10436  osu9207_Lubell_bkup  Shonna\namine1         data        jelmer_osu5685  osu5685   osu9390              SLocke\nap_soumya      demo        jlhartman       osu6702   osu9453              sochina\naudreyduff     dhanashree  linda           osu8107   osu9657\nbahodge11      edwin       Maggie          osu8468   pipeline\ncalconey       ferdinand   mcic-scripts    osu8548   poonam\ncamila         Fiama       Menuka          osu8618   raees\nCecilia        Flye        nghi            osu8900   rawalranjana44\n```\n\nAlong these lines, there are two other shortcuts worth mentioning:\n\n- **`~`** represents your Home directory,\n  so `cd ~` would move there and `ls ~` would list the files there\n\n- **`-`** is a `cd`-specific shortcut that it is like the \"back\" button in your\n  browser: it will go to your previous location.\n  (But it only has a memory of 1, so two subsequent `cd -` would move you back\n  to your current working directory.)\n  \n::: {.callout-note}\n#### These shortcuts work with all commands\n\nExcept for **`-`**,\nall of the above shortcuts are *general shell shortcuts* that work with **any**\ncommand that takes a path (and with nearly all say bioinformatics programs too).\n\n:::\n\n<br>\n\n## Recap\n\nWe've learned about structure of command line expressions in the Unix shell,\nwhich include: the _command_ itself, _options_, _arguments_, and _output_\n(including, in some cases, error messages).\n\nA few key general points to remember are that:\n\n- Commands that take **actions** like changing directory\n  (and the same will be true for commands that copy and move files, for example)\n  will by default **not print any output to the screen**,\n  only errors _if_ those occur.[^2]\n\n[^2]: We'll see later on how we can make commands more \"verbose\" than they are\n      by default, which can certainly be useful.\n\n- Commands whose main function it is to provide us with information\n  (think `ls`, `date`, `pwd`) will **print their output to the screen**.\n  We'll learn later how we \"redirect\" output to a file.\n\n- Using **options** (`ls -l`), we can modify the behavior of a command,\n  and using **arguments** (`ls data`), we can modify what it operates on in\n  the first place. \n\n::: {.callout-warning}\n#### Always start with a command\nOne additional, important thing to realize about the structure of command\nline expressions is this:\n\nEverything you type on the command line\nshould start with the name of a command, or equivalently, a program or script\n(these are all just \"programs\").\n\nTherefore, for example, just typing the name of a file,\neven if it exists in your current working directory,\nwill not do anything with that file (like printing its contents)\nlike you might have expected.\nThis is because the name of a file is not a command:\n\n```bash\nREADME.md\n```\n``` {.bash-out}\nREADME.md: command not found\n```\n:::\n\nWe've learned to work with the following truly ubiquitous Unix commands:\n\n - `pwd` &mdash; print your current working directory\n - `cd` &mdash; change your working directory\n - `ls` &mdash; list files and dirs\n\nAnd have seen a few other simpler utility commands as well\n(`date`, `whoami`).\n\nWe'll continue with the basics of the Unix shell in part II (TBA).\n\n::: {.callout-note}\n#### Many bioinformatics programs are basically specialized commands\nIn many ways,\nyou can think of using a command-line bioinformatics program as using just another command,\nso our general skills with Unix commands will very much extend to using command-line\nbioinformatics tools!\n:::\n\n<br>\n\n## At-home reading: getting help\n\nWe saw several different _options_ for the `ls` command,\nand that may have left you wondering how you are supposed to know about them.\n\n### The `--help` option\n\nMany commands have a `--help` option which will primarily describe the\ncommand's function and \"syntax\" including many of the available options.\n\nFor a very brief example, try:\n\n```bash\nwhoami --help\n```\n\nFor a much longer example, try:\n\n```bash\nls --help\n```\n\n### The `man` command\n\nThe `man` command provides manual pages for Unix commands,\nwhich is more complete than the `--help` help,\nbut sometimes overwhelming as well as terse and not always easy to fully understand \n&mdash; Google is your friend as well!\n\nFor a short example, try:\n\n```bash\nman pwd\n```\n\n::: {.callout-warning}\n#### The man page opens in a \"pager\" -- type <kbd>q</kbd> to quit!\n:::\n\nFor a much longer example, try:\n\n```bash\nman ls\n```\n\n<br> <br>",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}