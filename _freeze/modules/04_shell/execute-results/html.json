{
  "hash": "b0cc2a9084025bc010c3f5f767f7b047",
  "result": {
    "markdown": "---\ntitle: \"The Unix Shell - Part I\"\npagetitle: \"Unix shell part I\"\nhighlight-style: github\nnumber-sections: true\nengine: knitr\nauthor: Jelmer Poelstra\ndate: 2023-07-28\n---\n\n::: {.cell}\n\n:::\n\n\n-----\n\n<br>\n\n## Introduction\n\nMany of the things you typically do by pointing and clicking can alternatively\nbe done by typing commands.\nThe Unix shell allows you to interact with computers via commands.\nIt is natively available through a Terminal app in computers with Unix-like\noperating systems like Linux (on which OSC runs) or MacOS,\nand can also be installed on Windows computers with relatively\nlittle trouble these days\n(see the [SSH reference page on this website](../info/osc_ssh.qmd)).\n\nWorking effectively on a remote supercomputer tends to simply _require_ using a\ncommand line interface.\nBut there are more **advantages to doing command line computing**\nthan just allowing you to work on a supercomputer, such as:\n\n  - Working efficiently with large files\n  - Achieving better reproducibility in research\n  - Performing general computing tasks more efficiently, once you get the hang of it\n  - Making it much easier to repeat similar tasks across files, samples,\n    and projects, with the possibility of true automation\n  - For bioinformatics, being able to use (the latest) command-line programs directly\n    without having to depend on \"GUI wrappers\" written by third parties,\n    that often cost money and also lag behind in functionality\n\nIn these sessions, **we'll use a Unix shell at OSC inside VS Code**.\nFor this session, specifically,\nI will assume you still have an active VS Code session as setup in the\n[previous one](02_osc.qmd), have VS Code located at `/fs/ess/PAS0471`,\nand with an open Terminal &mdash; if not, see the instructions in the dropdown\nbox right below.\n\n[^1]: But just for reference, there are other ways of accessing a Unix shell at OSC:\nfor example, you can also get Shell access through the \"Clusters\" menu\nin OSC OnDemand,\nor you could connect your local Unix shell to OSC through SSH\n(again, [see this reference page](../info/osc_ssh.qmd)).\n\n:::{.callout-tip collapse=\"true\"}\n## Starting VS Code at OSC - with a Terminal (Click to expand)\n1. Log in to OSC's OnDemand portal at <https://ondemand.osc.edu>.\n2. In the blue top bar, select `Interactive Apps`\n   and then near the bottom of the dropdown menu, click `Code Server`.\n3. In the form that appears on a new page:\n   - Select an appropriate OSC project (here: `PAS0471`)\n   - For this session, select `/fs/ess/PAS0471` as the starting directory\n   - Make sure that `Number of hours` is at least `2`\n   - Click `Launch`.\n4. On the next page, once the top bar of the box has turned green\n   and says `Runnning`, click `Connect to VS Code`.\n\n<figure><p align=\"center\"><img src=img/osc-code-launch_ed.png width=\"80%\"></p></figure>\n\n5. Open a Terminal by clicking\n   &nbsp; {{< fa bars >}} &nbsp; => `Terminal` => `New Terminal`.\n   (Or use one of the keyboard shortcuts:\n   <kbd>Ctrl</kbd>+<kbd>\\`</kbd> (backtick) or\n   <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>C</kbd>.)\n6. Type `pwd` to check where you are.\n   If you are not in `/fs/ess/PAS0471`,\n   click `Open folder...` in the `Welcome` tab,\n   or &nbsp; {{< fa bars >}} &nbsp; => &nbsp; `File` &nbsp; => &nbsp; `Open Folder`,\n   then type/select `/fs/ess/PAS0471` and press Ok.\n:::\n\n::: {.callout-note}\n#### Some Terminology\n\nWe're going to focus on the practice of doing command line computing here,\nand not get too bogged down in terminology,\nbut let's highlight a few interrelated terms you're likely to run across:\n\n  - **Command Line** &mdash; the most general term, an interface where you type commands\n  - **Terminal** &mdash; the program/app/window that can run a Unix shell \n  - **Shell** &mdash; a command line interface to your computer\n  - **Unix Shell** &mdash; the types of shells on Unix family (Linux + Mac) computers \n  - **Bash** &mdash; the specific Unix shell language that is most common on Unix computers\n  - **Bash Shell** &mdash; a Unix shell that uses the Bash language\n  \nWhile it might not fly for a computer science class,\nfor day-to-day computing/bioinformatics,\nyou'll probably hear all these terms used somewhat interchangably.\nBasically, we're talking about the process of interacting with your computer by\ngiving it commands as opposed to the point-and-click way you're likely more familiar with.\n\n:::\n\n<br>\n\n## First steps\n\n### The prompt\n\nInside your terminal, the \"prompt\" indicates that the shell is ready for a command.\nWhat is shown exactly varies a bit across shells and can also be customized,\nbut our prompts at OSC should show the following:\n\n``` {.bash-in-nocolor}\n[<username>@<node-name> <working-dir>]$\n```\n\nFor example:\n\n``` {.bash-in-nocolor}\n[jelmer@p0080 PAS0471]$ \n```\n\nWe type our commands after the dollar sign,\nand then press <kbd>Enter</kbd> to execute the command.\nWhen the command has finished executing,\nwe'll get our prompt back and can type a new command.\n\n::: {.callout-tip}\n#### How shell code is presented on this website\nThe pale gray boxes like the ones shown above will be used to represent your\ncommand prompt, or rather, to show the command line expressions that you\nwill type.\n\nIn upcoming boxes, the prompt itself (`[...]$`) will not be shown,\nbut only the command line expressions that you type.\nThis is to save space and also because if we omit the prompt,\nyou will be able to directly copy and paste commands from the website to your shell. \n\nAlso, in a notation like `<username>`,\nthe `< >` are there to indicate this is not an actual, functional example,\nbut a descriptive generalization, and should not be part of the final code.\nIn this case, then, it should be replaced merely by a username (e.g. `jelmer`),\nand _not_ by `<jelmer>`, as you can see in the example with the prompt above.\n:::\n\n<br>\n\n### A few simple commands: `date`, `whoami`, `pwd`\n\nThe Unix shell comes with hundreds of commands.\nLet's start with a few simple ones.\n\nThe `date` command prints the current date and time:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ndate\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\nMon Jul 31 22:38:48 EDT 2023\n```\n:::\n:::\n\n\n::: {.callout-tip}\n#### Copying code from the website, and code output\nWhen you hover your mouse above the top box with the command\n(sometime you have to click in it first),\nyou should see a copy icon appear on the far right,\nwhich will copy the command to your clipboard:\nfor longer expressions, this can be handy so you can paste this right into your shell\nand don't have to type.\nGenerally speaking, though, learning works better when you type the commands yourself!\n\nAlso, the darker gray box below, with italic text,\nis intended to show the _output_ of commands as they are printed to the screen\nin the shell.\n:::\n\nThe `whoami` (who-am-i) command prints your username:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nwhoami\n```\n:::\n\n\n``` {.bash-out}\njelmer\n```\n\nThe `pwd` (Print Working Directory) commands prints the path to the directory\nyou are currently located in:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\npwd\n```\n:::\n\n\n``` {.bash-out}\n/fs/ess/PAS0471\n```\n\nAll 3 commands that we just used provided us with some output.\n_That output was **printed to screen**,\nwhich is the default behavior for nearly every Unix command_.\n\n:::{.callout-note}\n#### Working directories, and paths part I\n\nOn Unix systems,\nall the files on a computer exist within **a single hierarchical system of directories**\n(folders).\nWhen working in the Unix shell, you are always \"in\" one of these directories.\nThe directory you're \"in\" at any given time is referred to as your **working directory**.\n\nIn a **path** (specification of a file or directory location)\nsuch as that output by `pwd`, directories are separated by forward slashes `/`.\n\nA **leading forward slash** in a path indicates the root directory of the computer,\nand as such, the path provided by `pwd` is an _absolute path_ (or: _full path_),\nand not a _relative path_ &mdash; more on that later.\n\nWhile not shown in the `cd` output,\nif you _happen to see_ a **trailing forward slash** in a path\n(eg. `/fs/ess/PAS0471/`),\nyou can be sure that the path points to a directory and not a file.\n:::\n\n<br><br>\n\n## `cd` and command actions, defaults, and arguments\n\nIn the above three command line expressions:\n\n- We merely typed the _name of a command and nothing else_\n- The main function of the command was to _provide some information_,\n  which was the output printed to screen\n\nBut many commands perform an **action** other than printing output.\nFor example, the very commonly used command **`cd` (Change Directory)**\nwill, you guessed it,\nchange your working directory.\nAnd as it happens, it normally has no output at all.\n\nWe start by simply typing `cd`:\n\n``` {.bash-in-nocolor}\n[jelmer@p0080 PAS0471]$ cd\n[jelmer@p0080 ~]$\n```\n\nDid anything happen?\nYou might expect a command like `cd` to _report_ what it did, but it does not.\nAs a general rule for Unix commands that perform actions,\nand one that also applies to `cd`:\n**if the command does not print any output, this means it was successful.**\n\nSo where did we change our working directory to, given that we did not tell\n`cd` where to move?\nOur _prompt_ (as shown in the code box below) actually did give us a clue:\n`PAS0471` was changed to `~` But what does `~` mean?\n\n:::{.exercise}\n#### Your Turn: Check what directory we moved to {-}\n<details><summary>Solution (click here)</summary>\n```bash\npwd\n```\n```{.bash-out}\n/users/PAS0471/jelmer\n```\nIt appears that we moved to our Home directory!\n(Remember, we were in the Project directory `/fs/ess/PAS0471`.)\n\nAnd as it turns out,\n`~` is a shell shortcut to indicate your Home directory &mdash;\nmore on that later.\n\n</details>\n:::\n\nFrom this, we can infer that the **default behavior** of `cd`,\ni.e. when it is not given any additional information,\nis to move to a user's home directory.\nThis is actually a nice trick to remember!\n\nNow, let's move to another directory, one that contains some files we can explore\nto learn our next few commands.\nWe can do so by specifying the _path_ to that directory after the `cd` command\n(make sure to leave a space after `cd`!):\n\n```bash\ncd /fs/ess/PAS0471/demo/202307_rnaseq/\n```\n\n```bash\npwd\n```\n```{.bash-out}\n/fs/ess/PAS0471/demo/202307_rnaseq\n```\n\nIn more abstract terms, what we did above was to provide `cd` with an **argument**\n(namely, the path to the dir to move to).\nArguments generally tell commands what file or directory to operate on,\nand come at the end of a command line expression.\nThere should always be a space between the command and its argument(s)!\n\n::: {.callout-note collapse=\"true\"}\n#### Tab completion!! (Click to expand)\n\n- After typing `/fs/e`, press the <kbd>Tab</kbd> key!\n\n    ```{.bash-out-solo}\n    /fs/ess/\n    ```\n\n- After typing `/fs/ess/P`, press the <kbd>Tab</kbd> key.\n  Nothing will happen, so now press it quickly twice in succession.\n  \n  ```{.bash-out-solo}\n  Display all 709 possibilities? (y or n)\n  ```\n\n  Type `n`. Why does this happen?\n\n- After typing `/fs/ess/PAS04`, press the <kbd>Tab</kbd> key twice quickly in\n  succession (\"Tab-tab\").\n\n  ```{.bash-out-solo}\n  PAS0400/ PAS0409/ PAS0418/ PAS0439/ PAS0453/ PAS0456/ PAS0457/ PAS0460/ PAS0471/ PAS0472/ PAS0498/ \n  ```\n\n- After typing `/fs/ess/PAS0471/demo/2`, press the <kbd>Tab</kbd> key!\n\n  ```{.bash-out-solo}\n  /fs/ess/PAS0471/demo/202307_rnaseq/\n  ```\n\nThe tab completion feature will check for files/dirs present in the location\nyou're at,\nand based on the characters you've typed so for,\ncomplete the path as far as it can.\n\nSometimes it can't move forward at all because there are multiple files or dirs\nthat have the same next character.\nPressing \"Tab-tab\" will then show your options,\nthough in unusual circumstances like one above, there are so many that it asks\nfor confirmation.\nIn such cases, it's usually better to just keep typing assuming that you know\nwhere you want to go.\n\nIn general, though, Tab completion is an _incredibly_ useful feature that you should\ntry to get accustomed to using right away!\n:::\n\nAs we've seen, then, `cd` gives no output when it succesfully changed the\nworking directory (\"silence is golden\"!).\nBut let's also see what happens when it does not succeed &mdash;\nit gives the following error:\n\n```bash\ncd /fs/Ess/PAS0471\n```\n``` {.bash-out}\nbash: cd: /fs/Ess/PAS0471: No such file or directory\n```\n\n:::{.exercise}\n#### Your Turn: What was the problem with the path we specified? {-}\n<details><summary>Solutions (click here)</summary>\nWe used a capital E in `/Ess/` &mdash; this should have been `/ess/`.\n\nIn other words, paths (dir and file specifications) are **case-sensitive**\non Unix systems!\n</details>\n:::\n\n**In summary**, in this section we've learned that:\n\n- The **`cd` command** can be used to change your working directory\n- Unix commands like `cd` that perform **actions**\n  will by default only print output to screen when something goes wrong (i.e., errors)\n- Commands can have _default behaviours_ when they are not given specific directions\n- We can give commands like `cd` **arguments** to tell them what to do / operate on.\n\nNext, we'll learn about _options_ to commands in the context of the `ls` command.\n\n<br>\n\n## `ls` and command _options_\n\n### The default behavior of `ls`\n\nThe `ls` command, short for \"list\",\nis a quite flexible command to list files and directories:\n\n```bash\nls\n```\n``` {.bash-out}\ndata  metadata  README.md\n```\n\n(You should still be in `/fs/ess/PAS0471/demo/202307_rnaseq`.\nIf not, `cd` there first.)\n\n:::{.callout-tip}\n#### `ls` output colors\nUnfortunately, the `ls` output shown above does not show the different colors\nyou should see in your shell &mdash; here are some of the most common ones:\n\n- Entries in <span style=\"color: #0328fc\">blue</span> are directories\n  (like `data` and `metadata` above)\n- Entries in black are regular files (like `README.md` above)\n- Entries in <span style=\"color: #d92118\">red</span> are compressed files\n  (we'll see an example soon).\n:::\n\nThe default behavior of `ls` includes that it will:\n\n- List files and dirs inside our current working directory,\n  and do so _non-recursively_: it won't list files inside those directories, and so on.\n- Show as many files and dirs as it can on one line, each separated by a few spaces\n- Sort files and dirs alphabetically (and not separately so)\n- Not show any other details about the files, such as their size, owner, and so on.\n\nAll of this, and more, can be changed by providing `ls` with **options** and/or\n**arguments**.\n\n### First, more on arguments\n\nLet's start with an _argument_, since we're familiar with those in the context of `cd`.\nAny argument to `ls` should be **a path to operate on**.\nFor example, if we wanted to see what's inside that mysterious `data` dir,\nwe could type:\n\n```bash\nls data\n```\n```{.bash-out}\nfastq\n```\n\nWell, that's not much information, just another dir &mdash;\nso let's look inside that:\n\n```bash\nls data/fastq  # These will be shown in red in your output, since they are compressed\n```\n```{.bash-out}\nASPC1_A178V_R1.fastq.gz  ASPC1_G31V_R2.fastq.gz      Miapaca2_G31V_R1.fastq.gz\nASPC1_A178V_R2.fastq.gz  Miapaca2_A178V_R1.fastq.gz  Miapaca2_G31V_R2.fastq.gz\nASPC1_G31V_R1.fastq.gz   Miapaca2_A178V_R2.fastq.gz\n```\n\nAh, there are some gzipped FASTQ files!\nThese contain our sequence data, and we'll go and explore them in a bit.\n\nWe can also provide `ls` with **multiple arguments** &mdash;\nand it will nicely tell us which files are in each of the dirs we specified:\n\n```bash\nls data metadata\n```\n\n```{.bash-out}\ndata:\nfastq\n\nmetadata:\nmeta.tsv\n```\n\nMany Unix commands will accept multiple arguments (files or dirs to operate on),\nwhich can be very useful.\n\n### Options\n\nFinally, we'll turn to options.\nWhereas, in general, _arguments_ tell a command what to operate on,\n_options_ (also called \"flags\") will modify its behavior.\n\nFor example, we can call `ls` with the **option `-l`**\n(a dash followed by a lowercase L):\n\n```bash\nls -l \n```\n\n```{.bash-out}\ntotal 17\ndrwxr-xr-x 3 jelmer PAS0471 4096 Jul 27 11:53 data\ndrwxr-xr-x 2 jelmer PAS0471 4096 Jul 27 11:54 metadata\n-rw-r--r-- 1 jelmer PAS0471  963 Jul 27 16:48 README.md\n```\n\nNotice that it lists the same three items as our first `ls` call above,\nbut now, they're printed in a different format:\none item per line, with lots of additional information included.\nFor example, the date and time is that **when the file was last modified**,\nand the numbers just to the left of that (e.g., `4096`) show\nthe **file sizes** in bytes[^2].\n\n[^2]: Though these sizes are only directly useful for files, not dirs!\n      You can also ignore the `total 17` line at the top.\n\nLet's add another option, `-h` &mdash; before reading on,\ncan you pick out what it did to modify the output?\n\n```bash\nls -l -h\n```\n\n```{.bash-out}\ntotal 17K\ndrwxr-xr-x 3 jelmer PAS0471 4.0K Jul 27 11:53 data\ndrwxr-xr-x 2 jelmer PAS0471 4.0K Jul 27 11:54 metadata\n-rw-r--r-- 1 jelmer PAS0471  964 Jul 27 17:48 README.md\n```\n\nNote the difference in the format of the column reporting the sizes of the items listed\n&mdash; we now have \"human-readable filesizes\", \nwhere sizes on the scale of kilobytes will be shown in `K`s,\nof megabytes in `M`s,\nand of gigabytes in `G`s.\n\nMany options have a \"**long option**\" counterpart, i.e. a more verbose way of\nspecifying the option.\nFor example, `-h` can also be specified as `--human-readable`:\n\n```bash\nls -l --human-readable      # Output not shown, same as above\n```\n\n(And then there are also options that are only available in long format &mdash;\neven with case-sensitivity, one runs out of single-letter abbreviations at some point!)\n\nDespite that **short options** like the `-l` and `-s` we've seen (single-dash, single-letter)\nare very terse and may at times seem impossible to remember,\nthey are still often preferred with common Unix commands,\nbecause they are shorter to type &mdash;\nand keep in mind that you might use, say, `ls -lh` dozens if not hundreds of time\na day if you work in the Unix shell a lot.\n\nA very useful feature of \"short options\" is that they can be pasted together as\nfollows:\n\n```bash\nls -lh   # Output not shown, same as above\n```\n\n::: {.callout-note}\n#### More on the long-format output of `ls`\nThe figure below shows what information is shown in each of the columns\n(but note that it shows a different listing of files,\nand uses the new-to-us **`-a` option, short for \"all\"**,\nto also show \"hidden files\"):\n\n<p align=\"center\"><img src=img/long-ls.png width=\"80%\"></p>\n:::\n\n<br>\n\n### Combining options and arguments\n\nFinally, we can **combine options and arguments**,\nand let's do so take a closer look at our dir with FASTQ files &mdash;\nnow the `-h` option is especially useful because it makes it easy to see that the files\nvary between 4.1 MB and 5.3 MB in size:\n\n```bash\nls -lh data/fastq\n```\n\n``` {.bash-out}\ntotal 38M\n-rw-r--r-- 1 jelmer PAS0471 4.1M Jul 27 11:53 ASPC1_A178V_R1.fastq.gz\n-rw-r--r-- 1 jelmer PAS0471 4.2M Jul 27 11:53 ASPC1_A178V_R2.fastq.gz\n-rw-r--r-- 1 jelmer PAS0471 4.1M Jul 27 11:53 ASPC1_G31V_R1.fastq.gz\n-rw-r--r-- 1 jelmer PAS0471 4.3M Jul 27 11:53 ASPC1_G31V_R2.fastq.gz\n-rw-r--r-- 1 jelmer PAS0471 5.1M Jul 27 11:53 Miapaca2_A178V_R1.fastq.gz\n-rw-r--r-- 1 jelmer PAS0471 5.3M Jul 27 11:53 Miapaca2_A178V_R2.fastq.gz\n-rw-r--r-- 1 jelmer PAS0471 5.1M Jul 27 11:53 Miapaca2_G31V_R1.fastq.gz\n-rw-r--r-- 1 jelmer PAS0471 5.3M Jul 27 11:53 Miapaca2_G31V_R2.fastq.gz\n```\n\n(Beginners are often inclined to move to a directory when they just want to\n`ls` its contents, but its often more convenient to stay put and use an\nargument to `ls` instead, like we did above.)\n\n<br>\n\n### Recap of `ls`, arguments, and options\n\nIn summary, in this section we have learned that:\n\n- The `ls` command lists files (by default without additional info and non-recursively)\n\n- Using _arguments_, we tell `ls` (and other commands) what to operate on.\n  Arguments come at the end of the command line epxression, and are not preceded by\n  a dash or any other \"pointer\".\n  They are typically names of files or dirs, but can be other things too.\n\n- Using _options_, we can make `ls` (and other commands) show us the results in\n  different ways. They are preceded by at least one dash (`-`, like `-l`).\n\n::: {.callout-note}\n#### Other types of options\n\nThe options we've seen so far act as \"on/off switches\",\nand this is very common among Unix commands.\n\n**But some options are not on/off switches and accept values**\n(confusingly, these values can also be called \"arguments\" to options).\nFor example, the `--color` option to `ls` determines how it colorizes its output:\nthere is `ls --color=never` &mdash; versus, among other possibilities,\n`ls --color=always`.\n\nWe'll see _a lot_ of options that take values when running bioinformatics\nprograms,\n**such as to set specific analysis parameters** &mdash;\nfor example:\n`trim_galore --quality 30 --length 50` would set a minimum Phred quality score\nthreshold of 30 and a minimum read length threshold of 50 bases for the program\nTrimGalore, which we will later use to quality-trim and adapter-trim FASTQ files.\n(This `--<option> <value>` syntax, i.e. without an `=` is more common than\nthe `--<option>=<value>` syntax shown for `ls` above.)\n\nIn contrast to when you are using common Unix commands, I would recommend to mostly\n_use **long options** whenever available when running bioinformatics programs like TrimGalore._\nThat way, itâ€™s easier for you to remember what you did with that option,\nand more likely to be immediately understood by anyone else reading the code\n(cf. `trim_galore -q 30 -l 50` and `trim_galore --quality 30 --length 50`).\n:::\n\n::: {.callout-note collapse=\"true\"}\n#### The `tree` command and recursive `ls` (Click to expand)\n\nThe `tree` command lists files _recursively_ (i.e., it will also show us what's\ncontained in the directories in our working directory),\nand does so in a tree-like fashion &mdash;\nthis can be great to quickly get an intuitive overview of files in a dir:\n\n```bash\ntree -C     # The -C option will colorize the output\n```\n<p align=\"left\"><img src=img/tree_output.png width=\"50%\"></p>\n\nAs an aside: if we want to make `ls` list files recursively,\nwe can use the `-R` option:\n\n```bash\nls -R\n```\n```{.bash-out}\n.:\ndata  metadata  README.md\n\n./data:\nfastq\n\n./data/fastq:\nASPC1_A178V_R1.fastq.gz  ASPC1_G31V_R2.fastq.gz      Miapaca2_G31V_R1.fastq.gz\nASPC1_A178V_R2.fastq.gz  Miapaca2_A178V_R1.fastq.gz  Miapaca2_G31V_R2.fastq.gz\nASPC1_G31V_R1.fastq.gz   Miapaca2_A178V_R2.fastq.gz\n\n./metadata:\nmeta.tsv\n```\n\n:::\n\n<br>\n\n## Paths\n\nAs we've mentioned,\n\"paths\" are specifications of a location on a computer,\neither of a file or a directory.\n\nWe've talked about the commands `cd` and `ls` that operate on paths,\nand without going into much detail about it so far, \nwe've already seen two distinct ways of specifying paths:\n\n- **Absolute (full) paths** always start from the root directory of the computer,\n  which is represented by a _**leading `/`**_, such as in `/fs/scratch/PAS0471/`.\n  \n  _(Absolute paths are like GPS coordinates to specify a geographic location on earth:_\n  _they will provide location information regardless of where we are ourselves.)_\n\n- **Relative paths** start from your current location (working directory).\n  When we typed `ls data` earlier,\n  we indicated that we wanted to show the contents of the\n  `data` directory located inside our current working directory &mdash;\n  that probably seemed intuitive.\n  But be aware that the shell would look absolutely nowhere else for that dir\n  than in our current working directory.\n\n  (_Relative paths are more like directions to a location that say things like_\n  _\"turn left\" &mdash; these instructions depend on our current location._)\n\nAbsolute paths may seem preferable because they will work regardless of where\nyou are located, **but**:\n\n- They can be a lot more typing than we need (or want) to do.\n- While context-specific, a much more important disadvantage of absolute paths\n  is that they can only be expected to work on one specific computer,\n  and are guaranteed not to work after you move files around.\n\n:::{.exercise}\n#### How might relative dirs work on other computers or after moving files? {-}\n<details><summary>Solution (click here)</summary>\n\nSay that Lucie has a directory for a research project, `/fs/ess/PAS0471/lucie/rnaseq1`,\nwith lots of dirs and files contained in it.\nIn all her code, she specify paths relative to that top-level project directory.\n\nThen, she share that entire directory with someone else, copying it off OSC.\nIf her collaborator goes wherever _they_ now have that directory stored,\ne.g. `/home/philip/lucie_collab/rnaseq1`, and then start using Lucie's code\nwith relative paths, **they would still work**.\n\nSimilarly, if Lucie moves her dir to `/fs/scratch/PAS0805/lucie/rnaseq1`,\nall her code with relative paths **would still work as well**.\n\nThis is something we'll come back to later when talking about reproducibity.\n</details>\n:::\n\n<br>\n\n### Moving \"up\" when using relative paths\n\nThere are a couple of \"shortcuts\" available for relative paths.\nFirst of all,\n`.` (a single period) is another way of representing the current working directory.\nTherefore, for instance,\n`ls ./data` is functionally the same as `ls data`,\nand just a more explicit way of saying that the `data` dir is located in your\ncurrent working dir (this syntax is occasionally helpful).\n\nMore usefully for our purposes here, **`..` (two periods) means one level up**\nin the directory hierarchy, with \"up\" meaning towards the root directory\n(I guess the directory tree is best visualized upside down!):\n\n```bash\nls ..               # One level up, listing /fs/ess/PAS0471/demo\n```\n```{.bash-out}\n202307_rnaseq\n```\n\nThis pattern can be continued all the way to the root of the computer,\nso `../..` would list files two levels up:\n\n```bash\nls ../..            # Two levels up, listing /fs/ess/PAS0471\n```\n```{.bash-out}\naarevalo       conroy      frederico       Nisha     osu8947              ross\nacl            containers  hsiangyin       osu10028  osu9207              Saranga\nAlmond_Genome  danraywill  jelmer          osu10436  osu9207_Lubell_bkup  Shonna\namine1         data        jelmer_osu5685  osu5685   osu9390              SLocke\nap_soumya      demo        jlhartman       osu6702   osu9453              sochina\naudreyduff     dhanashree  linda           osu8107   osu9657\nbahodge11      edwin       Maggie          osu8468   pipeline\ncalconey       ferdinand   mcic-scripts    osu8548   poonam\ncamila         Fiama       Menuka          osu8618   raees\nCecilia        Flye        nghi            osu8900   rawalranjana44\n```\n\nAlong these lines, there are two other shortcuts worth mentioning:\n\n- **`~`** represents your Home directory,\n  so `cd ~` would move there and `ls ~` would list the files there\n\n- **`-`** is a `cd`-specific shortcut that it is like the \"back\" button in your\n  browser: it will go to your previous location.\n  (But it only has a memory of 1, so subsequent `cd -`s would simply move you\n  back and forth between two directories.)\n  \n::: {.callout-note}\n#### These shortcuts work with all commands\nExcept for **`-`**,\nall of the above shortcuts are *general shell shortcuts* that work with **any**\ncommand that takes a path.\n:::\n\n<br>\n\n## Recap\n\nWe've learned about structure of command line expressions in the Unix shell,\nwhich include: the _command_ itself, _options_, _arguments_, and _output_\n(including, in some cases, error messages).\n\nA few key general points to remember are that:\n\n- Commands that take **actions** like changing directory\n  (and the same will be true for commands that copy and move files, for example)\n  will by default **not print any output to the screen**,\n  only errors _if_ those occur.[^3]\n\n[^3]: We'll see later on how we can make commands more \"verbose\" than they are\n      by default, which can certainly be useful.\n\n- Commands whose main function is to provide information\n  (think `ls`, `date`, `pwd`) will **print their output to the screen**.\n  We'll learn later how we can \"redirect\" output to a file or to another command!\n\n- Using **options** (`ls -l`), we can modify the behavior of a command,\n  and using **arguments** (`ls data`), we can modify what it operates on in\n  the first place. \n\n::: {.callout-warning}\n#### Always start with a command\nOne additional, important thing to realize about the structure of command\nline expressions is this:\n\nEverything you type on the command line\nshould start with the name of a command, or equivalently, a program or script\n(these are all just \"programs\").\n\nTherefore, for example, just typing the name of a file,\neven if it exists in your current working directory,\nwill return an error.\n(I.e., it won't do anything with that file, such as printing its contents,\nlike you had perhaps expected.)\nThis is because the first word of a command line expressio should be a command,\nand the name of a file is (usually!) not a command:\n\n```bash\nREADME.md\n```\n``` {.bash-out}\nREADME.md: command not found\n```\n:::\n\n::: {.callout-note}\n#### Many bioinformatics programs are basically specialized commands\nIn many ways, as mentioned in the box above,\nyou can think of using a command-line bioinformatics program as using just another command.\n\nTherefore, our general skills with Unix commands will very much extend to using\ncommand-line bioinformatics tools!\n:::\n\nWe've learned to work with the following truly ubiquitous Unix commands:\n\n - `pwd` &mdash; print your current working directory\n - `cd` &mdash; change your working directory\n - `ls` &mdash; list files and dirs\n\nAnd we have seen a few other simpler utility commands as well\n(`date`, `whoami`, and `tree` in a dropdown box).\n\nWe'll continue with the basics of the Unix shell in part II (TBA).\n\n\n\n<br>\n\n## At-home reading: getting help\n\nWe saw several different _options_ for the `ls` command,\nand that may have left you wondering how you are supposed to know about them.\n\n### The `--help` option\n\nMany (but not all!) commands have a `--help` option which will primarily describe\nthe command's function and \"syntax\" including many of the available options.\n\nFor a very brief example, try:\n\n```bash\nwhoami --help\n```\n\nFor a much longer example, try:\n\n```bash\nls --help\n```\n\n### The `man` command\n\nThe `man` command provides manual pages for Unix commands,\nwhich is more complete than the `--help` help,\nbut sometimes overwhelming as well as terse and not always easy to fully understand \n&mdash; Google is your friend as well!\n\nFor a short example, try:\n\n```bash\nman pwd\n```\n\n::: {.callout-warning}\n#### The man page opens in a \"pager\" -- try to scroll around and type <kbd>q</kbd> to quit!\n:::\n\nFor a much longer example, try:\n\n```bash\nman ls\n```\n\n<br> <br>",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}