{
  "hash": "f1eef763ace5ff41ac6d537ef0d1d112",
  "result": {
    "markdown": "---\ntitle: \"Trimming with _TrimGalore_\"\npagetitle: \"TrimGalore\"\nhighlight-style: github\nnumber-sections: true\nengine: knitr\nauthor: Jelmer Poelstra\ndate: 2023-10-01\n---\n\n\n::: {.callout-important}\n## Under construction \nThis page is still under construction.\n:::\n\n-------\n\n<br>\n\n## Overview & setting up {-}\n\nIn this session, we will run _TrimGalore_ to filter our FASTQ files, removing:\n\n- Any adapter sequences that are present in the reads\n- Poor-quality bases at the start and of the reads\n- Reads that have become excessively short after the prior two steps\n\n[Discuss that this step is sometimes considered optional:\nmappers should be able to deal with poor-quality bases and adapter sequences.]\n\n[Discuss how there are several programs commonly used for this, including\n`TrimGalore`, `Trimmomatic`, and `fastp` -- and that in general, these are exchangeable.]\n\n[Discuss how TrimGalore is \"just\" a wrapper around `CutAdapt`,\nand that it can also run FastQC on the processed sequences.]\n\n<br>\n\n## Using TrimGalore at OSC\n\n_TrimGalore_ isn't installed at OSC,\nso we'll use my _Conda_ environment for _TrimGalore_ like we did with _MultiQC_:\n\n```bash\nmodule load miniconda3\nsource activate /fs/ess/PAS0471/jelmer/conda/trimgalore\n```\n\nLet's see if we can now run it &mdash;\nnot that the command is `trim_galore` with an underscore:\n\n```bash\ntrim_galore --version\n```\n```{.bash-out}\n\n            Quality-/Adapter-/RRBS-/Speciality-Trimming\n                    [powered by Cutadapt]\n                        version 0.6.10\n\n                    Last update: 02 02 2023\n```\n\n::: {.callout-note collapse=\"true\"}\n#### How you can create your own TrimGalore Conda environment (click to expand) \n\n```bash\n# Make sure the load the latest miniconda version when doing installations\nmodule load miniconda3/23.3.1-py310\n\n# Create a new environment called 'trimgalore' and install the program into it\nconda create -y -n trimgalore -c bioconda trim-galore\n```\n:::\n\n<br>\n\n## TrimGalore syntax\n\n```bash\ntrim_galore --help\n\n# Note: Below I am only showing (truncated) output for the key options!\n```\n```{.bash-out}\n USAGE:\ntrim_galore [options] <filename(s)>\n\n-o/--output_dir <DIR>   If specified all output will be written to this directory instead of the current\n                        directory. If the directory doesn't exist it will be created for you.\n-j/--cores INT          Number of cores to be used for trimming [default: 1].\n--fastqc                Run FastQC in the default mode on the FastQ file once trimming is complete.\n--fastqc_args \"<ARGS>\"  Passes extra arguments to FastQC.\n-a/--adapter <STRING>   Adapter sequence to be trimmed. If not specified explicitly, Trim Galore will\n                        try to auto-detect whether the Illumina universal, Nextera transposase or Illumina\n                        small RNA adapter sequence was used.\n-q/--quality <INT>      Trim low-quality ends from reads in addition to adapter removal.\n--length <INT>          Discard reads that became shorter than length INT because of either\n                        quality or adapter trimming. A value of '0' effectively disables\n                        this behaviour. Default: 20 bp.\n```\n\nThe line under \"USAGE:\" tells us that the FASTQ file names should be specified\nas **positional arguments at the end of the command**.\nAny of options (like `--output_dir`) that we may want to use should come in between\nthe `trim_galore` command and the FASTQ file names.\n\n_It is important to realize that we will run TrimGalore for one **sample** at a time_\n_and therefore for two FASTQ files (forward/R1 and reverse/R2) at a time._\nBy comparison, we were able to run FastQC simply for one FASTQ file at a time.\nSo, without any options, and fictional FASTQ files `A_R1.fastq.gz` and `A_R2.fastq.gz`,\nour command would be:\n\n```bash\n# (Don't run this, fictional example command)\ntrim_galore A_R1.fastq.gz A_R2.fastq.gz\n```\n\nAs for the options:\n\n- We will use TrimGalore with **default settings** for:\n\n  - The trimming of adapters (`--adapter` option, default: auto-detect the adapters used)\n  - The minimum base quality threshold (`--quality` option, default: Phred score of 20)\n  - The minimum read length threshold (`--length` option, default: 20 bp)\n\n    ...but it's good to know we could easily change those if we wanted to.\n\n- We do want to specify the **output directory**,\n  since it's pretty annoying to get output files in the current working dir:\n  we could for instance use **`--output_dir results/trimgalore`**.\n\n- We'll typically also want to have TrimGalore **run FastQC** on the filtered FASTQ files,\n  since it will be good to check if adapter sequences were successfully removed and so on.\n  \n  When we do so, we'll also have to tell FastQC about the output dir of its files:\n  we can do so via `--fastqc_args`\n  (and using that option will trigger the running of FastQC, i.e.,\n  there is no need to also use `--fastqc`).\n  \n  So, we could use **`--fastqc_args \"--outdir results/trimgalore/fastqc\"`**.\n\n- Finally, we'll usually want to specify the number of cores,\n  and it should correspond to what we have available for our compute job.\n  \n  Since we have 1 core in the VS Code session,\n  we'll use **`--cores 1`** in the test-run,\n  but something else in our final script.\n\nA final test command to run TrimGalore on our actual (but small, subsetted)\nFASTQ files in `data/fastq` could therefore look as follows:\n\n```bash\n# For clarity, using one argument/option per line\ntrim_galore \\\n    --output_dir results/trimgalore \\\n    --cores 1 \\\n    --fastqc_args \"--outdir results/trimgalore/fastqc\" \\\n    --paired data/fastq/ASPC1_A178V_R1.fastq.gz data/fastq/ASPC1_A178V_R2.fastq.gz\n```\n\nLet's try that out.\n\nYou should have gotten _a lot_ of logging output,\nwhich was also saved ...\n\nLet's look at what the output files are:\n\n```bash\nls -lhR results/trimgalore\n```\n\n<br>\n\n## Variables in a script to run TrimGalore\n\nTo run TrimGalore efficiently at OSC,\nwe will submit a compute job to run TrimGalore separately for each sample.\n\nWe'll have to make our TrimGalore flexible such that it is able to take one or two\n**arguments** to specify the input FASTQ files.\nThis can be one in several ways, but we'll do it as follows:\nwe'll only pass an R1 FASTQ file to the script,\nwhich will then infer the name of the R2 file (by replacing `_R1` with `_R2`).\nThis is generally easiest because it allows us to simply loop over the R1 FASTQ\nfiles in our \"runner script\".\n\nLike we've done with out FastQC and MultiQC script,\nwe'll also include an argument with the output directory name,\nsomething that is also good practice to not hardcode in your script.\n\nLet's start by just thinking about we would define this variables for a single\nsample, and how the TrimGalore command would change:\n\n```bash\n# Variables defined upfront - passed as arguments to the script\nR1=data/fastq/ASPC1_A178V_R1.fastq.gz\noutdir=results/trimgalore\n\n# \"Derived\" variables\nn_cores=$SLURM_CPUS_ON_NODE\nR2=${R1/_R1/_R2}\n\n# The Trimgalore call:\ntrim_galore \\\n    --output_dir \"$outdir\" \\\n    --cores \"$n_cores\" \\\n    --fastqc_args \"--outdir \"$outdir\"/fastqc\" \\\n    --paired \"$R1\" \"$R2\"    \n```\n\n<br>\n\n## A script to run TrimGalore\n\n```bash\n#!/bin/bash\n#SBATCH --account=PAS0471\n#SBATCH --time=1:00:00\n#SBATCH --cpus-per-task=8\n#SBATCH --mem=32G\n#SBATCH --job-name=trimgalore\n#SBATCH --output=slurm-trimgalore-%j.out\n\n# Re-assign positional parameters\nR1=$1\noutdir=$2\n\n# Load the Conda environment\nmodule load miniconda3\nsource activate /fs/ess/PAS0471/jelmer/conda/trimgalore\n\n# Use strict Bash settings\nset -euo pipefail\n\n# Infer derived variables\nn_cores=$SLURM_CPUS_ON_NODE\nR2=${R1/_R1/_R2}\n\n# Report\necho \"# Starting script trimgalore.sh\"\ndate\necho \"# Input R1 FASTQ file:      $R1\"\necho \"# Output dir:               $outdir\"\necho\n\n# Check that the output dir isn't the same as the input dir\n# This is because we will let the output files have the same name as the input files\nif [[ $(dirname \"$R1\") == \"$outdir\" ]]; then\n    echo \"# ERROR: Input dir is the same as the output dir ($outdir)\" \n    exit 1\nfi\n\n# Create the output dir\nmkdir -p \"$outdir\" \"$outdir\"/fastqc\n\n# Run TrimGalore\ntrim_galore \\\n    --output_dir \"$outdir\" \\\n    --cores \"$n_cores\" \\\n    --fastqc_args \"--outdir $outdir/fastqc\" \\\n    --paired \"$R1\" \"$R2\"\n\n# Rename output files\necho -e \"\\n# Renaming the output files:\"\nfile_id=$(basename \"$R1\" _R1.fastq.gz)\nR1_out=\"$outdir\"/\"$file_id\"_R1_val_1.fq.gz\nR2_out=\"$outdir\"/\"$file_id\"_R2_val_2.fq.gz\nmv -v \"$R1_out\" \"$outdir\"/\"$file_id\"_R1.fastq.gz\nmv -v \"$R2_out\" \"$outdir\"/\"$file_id\"_R2.fastq.gz\n\n# Report\necho -e \"\\n# Done with script trimgalore.sh\"\ndate\necho -e \"\\n# Listing files in the output dir:\"\nls -lh \"$outdir\"\n```\n\n",
    "supporting": [
      "B03_trimgalore_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}