{
  "hash": "edb130dbe9cd3a52091216853aca869a",
  "result": {
    "markdown": "---\ntitle: \"Overview of next steps, and shell variables & `for` loops\"\nsubtitle: \"Starting with a bird's-eye view of how we will be running CLI bioinformatics programs\"\npagetitle: \"Running bioinformatics programs\"\nhighlight-style: github\nnumber-sections: true\nengine: knitr\nauthor: Jelmer Poelstra\ndate: 2023-08-25\n---\n\n::: {.cell}\n\n:::\n\n\n-------\n\n<br>\n\n## Overview & setting up {-}\n\nIn this session, we'll start by looking ahead a bit.\nYou will get an overview of how we will be running bioinformatics programs with\ncommand-line interfaces (CLIs) during the first part of the RNAseq analysis,\nwhere we start with reads in FASTQ files and will produce a table with gene counts.\nThis overview is meant to clarify\n**which fundamentals we still need to cover before we can start running these analyses.**\n\nThen, we'll talk about the first of those remaining fundamental topics:\n**shell variables** and **`for` loops**.\nThe next few sessions will cover the remaining ones:\n\n- [Writing shell scripts](./A08_scripts.qmd)\n- [Using software at OSC](./A09_software.qmd)\n- [Submitting scripts to the OSC job queue](./A10_slurm.qmd).\n\n### Start VS Code and open your folder {-}\n\nAs always, we'll be working in VS Code &mdash;\nif you don't already have a session open, see below how to do so.\n\n**Make sure to open your `/fs/ess/PAS0471/<user>/rnaseq_intro` dir**,\neither by using the `Open Folder` menu item,\nor by clicking on this dir when it appears in the `Welcome` tab.\n\n:::{.callout-tip collapse=\"true\"}\n## Starting VS Code at OSC - with a Terminal (Click to expand)\n1. Log in to OSC's OnDemand portal at <https://ondemand.osc.edu>.\n\n2. In the blue top bar, select `Interactive Apps`\n   and then near the bottom of the dropdown menu, click `Code Server`.\n\n3. In the form that appears on a new page:\n   - Select an appropriate OSC project (here: `PAS0471`)\n   - For this session, select `/fs/ess/PAS0471` as the starting directory\n   - Make sure that `Number of hours` is at least `2`\n   - Click `Launch`.\n\n4. On the next page, once the top bar of the box has turned green\n   and says `Runnning`, click `Connect to VS Code`.\n\n<figure><p align=\"center\"><img src=img/osc-code-launch_ed.png width=\"80%\"></p></figure>\n\n5. Open a Terminal by clicking\n   &nbsp; {{< fa bars >}} &nbsp; => `Terminal` => `New Terminal`.\n   (Or use one of the keyboard shortcuts:\n   <kbd>Ctrl</kbd>+<kbd>\\`</kbd> (backtick) or\n   <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>C</kbd>.)\n\n6. In the `Welcome` tab under `Recent`,\n   you should see your `/fs/ess/PAS0471/<user>/rnaseq_intro` dir listed:\n   click on that to open it.\n   Alternatively, use\n   &nbsp; {{< fa bars >}} &nbsp; => &nbsp; `File` &nbsp; => &nbsp; `Open Folder`\n   to open that dir in VS Code.\n:::\n\n:::{.callout-warning collapse=\"true\"}\n#### Don't have your own dir with the data? (Click to expand)\nIf you missed the last session, or deleted your `rnaseq_intro` dir entirely,\nrun these commands to get a (fresh) copy of all files you should have so far:\n\n```bash\nmkdir -p /fs/ess/PAS0471/$USER/rnaseq_intro\ncp -r /fs/ess/PAS0471/demo/202307_rnaseq /fs/ess/PAS0471/$USER/rnaseq_intro\n```\n\nAnd if you do have an `rnaseq_intro` dir,\nbut you want to start over because you moved or removed some of the files\nwhile practicing, then delete the dir before your run the commands above:\n\n```bash\nrm -r /fs/ess/PAS0471/$USER/rnaseq_intro\n```\n\nYou should have at least the following files in this dir:\n\n```{.bash-out}\n/fs/ess/PAS0471/demo/202307_rnaseq\n├── data\n│   └── fastq\n│       ├── ASPC1_A178V_R1.fastq.gz\n│       ├── ASPC1_A178V_R2.fastq.gz\n│       ├── ASPC1_G31V_R1.fastq.gz\n│       ├── ASPC1_G31V_R2.fastq.gz\n│       ├── md5sums.txt\n│       ├── Miapaca2_A178V_R1.fastq.gz\n│       ├── Miapaca2_A178V_R2.fastq.gz\n│       ├── Miapaca2_G31V_R1.fastq.gz\n│       └── Miapaca2_G31V_R2.fastq.gz\n├── metadata\n│   └── meta.tsv\n└── README.md\n│   └── ref\n│       ├── GCF_000001405.40.fna\n│       ├── GCF_000001405.40.gtf\n```\n:::\n\n<br>\n\n## Running CLI bioinformatics programs at OSC: an overview\n\nAs pointed out earlier,\nbioinformatics software (programs) that we use to analyze genomic data are\ntypically run from the command line.\nThat is,\nthey have a \"command-line interface\" (*CLI*) rather than a\n\"graphical user interface\" (*GUI*),\nand are run\n_using command line expressions that are structurally very similar to how we've_\n_been using basic Unix shell commands._\n\nHere, we'll use the program _FastQC_ as an example,\nwhich performs quality control (QC) on a FASTQ file, \nand is often the very first step when analyzing a newly sequenced genomics dataset.\n\n### Running a CLI program interactively\n\nWhen we run a bioinformatics program at OSC,\nwe'll always have to first make the program available to us.\nWe will cover that in more in detail in the session [Software at OSC](A09_software.qmd)\n&mdash; but here is how you can do this for _FastQC_:\n\n```bash\n# Load the OSC \"module\" for FastQC, so we can use this program\nmodule load fastqc\n```\n\nNext, we could run _FastQC_ for one of our FASTQ files as follows:\n\n```bash\n# First create the output dir\nmkdir -p results/fastqc\n\n# Tell FastQC about the output dir with --outdir, and pass the file name as an argument\nfastqc --outdir results/fastqc data/fastq/ASPC1_A178V_R1.fastq.gz\n```\n```{.bash-out}\nStarted analysis of ASPC1_A178V_R1.fastq.gz\nApprox 5% complete for ASPC1_A178V_R1.fastq.gz\nApprox 10% complete for ASPC1_A178V_R1.fastq.gz\nApprox 15% complete for ASPC1_A178V_R1.fastq.gz\n# [...truncated]\nApprox 95% complete for ASPC1_A178V_R1.fastq.gz\nApprox 100% complete for ASPC1_A178V_R1.fastq.gz\nAnalysis complete for ASPC1_A178V_R1.fastq.gz\n```\n```bash\nls -lh results/fastqc\n```\n```{.bash-out}\ntotal 736K\n-rw-r--r-- 1 jelmer PAS0471 266K Aug 15 10:39 ASPC1_A178V_R1_fastqc.html\n-rw-r--r-- 1 jelmer PAS0471 456K Aug 15 10:39 ASPC1_A178V_R1_fastqc.zip\n```\n\nThat seems to have worked!\nWe have two output files,\nincluding an HTML file that contains figures with all the results for this\none FASTQ file.\n\nSo should we simply repeat this for the rest of our FASTQ files?\nI.e., we could run a `fastqc` command 7 times more,\neach time passing a different input file as the argument.\nThat seems a bit tedious,\nand remember that the full dataset contains even more files...\n\n::: {.callout-note}\nFor completeness' sake, I should mention that it is in fact possible\nto pass multiple files as argument to `fastqc`.\nIf we did that, we'd only need to run _FastQC_ once,\nand would not need the approach shown below, where we use a loop.\n\nHowever, using a loop is a very general approach,\nand is necessary for the many programs that can only run one FASTQ file or one\nsample at a time.\nWhen using a supercomputer like OSC,\nthis is _also_ by far the most time-efficient approach,\nbecause it allows each sample/file to be processed in parallel rather than\nconsecutively.\n:::\n\n### Looping over input files\n\nWe can avoid using a very similar command a whole bunch of times\nby using a **loop**.\n\nFurther down on this page,\nwe will learn all about [`for` loops](#for-loops).\nHere, we'll again just see a quick example,\nand it is not yet important to understand the details of the code below,\nwhich will \"loop over\" all FASTQ files in the `data/fastq` dir,\nand run _FastQC_ for one file at a time:\n\n```bash\nfor fastq_file in data/fastq/*fastq.gz; do\n    fastqc --outdir results/fastqc \"$fastq_file\"\ndone\n```\n```{.bash-out}\nStarted analysis of ASPC1_A178V_R1.fastq.gz\nApprox 5% complete for ASPC1_A178V_R1.fastq.gz\n# [...]\nStarted analysis of ASPC1_A178V_R2.fastq.gz\nApprox 5% complete for ASPC1_A178V_R2.fastq.gz\n# [...]\nStarted analysis of ASPC1_G31V_R1.fastq.gz\nApprox 5% complete for ASPC1_G31V_R1.fastq.gz\n# [...]\n# [Output for all remaining files follows...]\n```\n\nThat's a lot better than repeating a similar line of codes many times &mdash;\nand the loop code would be exactly the same regardless of whether we had\n8 or 200 FASTQ files!\n\nHowever, recall that our full dataset also has _much larger_ FASTQ files.\nA _FastQC_ run on one of these will take several minutes,\nso our loop might take a while to finish\n(and note that some of the programs we'll run later take much longer than this).\nMost of all, when we run the program interactively and consecutively like this,\nwe are not making use of the supercomputer's strengths at all:\nthis is basically like running it on our own laptop,\nsince each _FastQC_ run happens consecutively.\n\n### Running the program with a shell script\n\nWe should instead submit a separate compute job for each _FastQC_ run,\nand these can then all run in parallel (i.e., at the same time)\non different OSC compute nodes.\nMaking the switch from interactively running _FastQC_\nto submitting each run as a compute job\nwill involve _two steps_:\n\n1. Putting the code to run _FastQC_ **inside a shell script**\n2. **Submitting** that shell script to the OSC compute job queue with `sbatch`\n   (rather than directly _running_ it)\n\nWe will cover the basics of shell scripts in the\n[session on shell scripts](./A08_scripts.qmd) &mdash;\nfor now, you just need to know that these scripts are small text files \n(with the extension `.sh`) that basically contain the same kind of shell code\nwe've been running interactively, with some added bells and whistles.\n\nIf for now we just assume we had created such a script,\nthen we can modify our loop code as follows to run _FastQC_ through a script,\ninstead of including the command to run the program directly in the loop:\n\n```bash\n# Don't run this - meant as an example only (you don't have this script yet)\nfor fastq_file in data/fastq/*fastq.gz; do\n    bash scripts/fastqc.sh \"$fastq_file\"\ndone\n```\n```{.bash-out}\nStarted analysis of ASPC1_A178V_R1.fastq.gz\nApprox 5% complete for ASPC1_A178V_R1.fastq.gz\n# [...]\nStarted analysis of ASPC1_A178V_R2.fastq.gz\nApprox 5% complete for ASPC1_A178V_R2.fastq.gz\n# [...]\nStarted analysis of ASPC1_G31V_R1.fastq.gz\nApprox 5% complete for ASPC1_G31V_R1.fastq.gz\n# [...]\n# [Output for all remaining files follows...]\n```\n\nHowever,\n**running that loop would still make _FastQC_ run _sequentially_**\non the node that we are at,\ninstead of in parallel on different compute nodes.\nWith the `fastqc.sh` script,\nwe've set ourselves up to be able to submit batch jobs,\nbut just using this script in itself does not change much.\n\n### Submitting the script to the job scheduler (many times)\n\nTo run our script in parallel,\nwe will use the `sbatch` command,\nwhich will submit the script to the Slurm job scheduler in every iteration of\nthe loop (i.e., as many times as we have input files):\n\n```bash\n# Don't run this - meant as an example only (you don't have this script yet)\nfor fastq_file in data/fastq/*fastq.gz; do\n    sbatch --account=PAS0471 scripts/fastqc.sh \"$fastq_file\"\ndone\n```\n```{.bash-out}\nSubmitted batch job 23510054\nSubmitted batch job 23510055\n# [Output truncated...]\n```\n\nWe will learn about `sbatch` and associated commands,\nas well as the different options you can use to specify the resources you want to\nrequest (how much time, how many cores, etc),\nin the [session on Slurm compute jobs](./A10_slurm.qmd).\n\n### Summarizing what we need to learn about\n\n- **`for` loops and variables**  \n  **`for` loops** will allow you to repeat operations &mdash;\n  specifically, we will later use them to submit many scripts at the same time,\n  one per input file or sample.\n  Using **variables** will allow you to run scripts flexibly,\n  with different input files and settings; they are also used in loops.\n  _We'll talk about these in the sections below._\n\n- **Making software available**  \n  At OSC, a bunch of bioinformatics programs are installed system-wide,\n  but they still need to be \"loaded\" via `module load`.\n  This collection of programs is unfortunately not comprehensive and we also\n  need another approach, as we'll see in the\n  [session Software at OSC](./A09_software.qmd).\n\n- **Writing shell scripts**  \n  Putting the code to run individual bioinformatics programs inside small shell\n  scripts will allow us to submit them to Slurm job scheduler.\n  Using scripts is more generally useful for e.g. long-running commands or programs,\n  and is a good way to keep your code organized and clear.\n  We'll talk about [shell scripts in the next session](./A08_scripts.qmd).\n\n- **Submitting scripts to the Slurm job scheduler**  \n  Submitting scripts as Slurm batch jobs at OSC allows us, for example,\n  to run the same analysis for different samples simultaneously.\n  We'll see this in more detail in the [session on Slurm jobs](./A10_slurm.qmd). \n\n<br>\n\n## Variables\n\nIn programming, we use **variables** for things that:\n\n  - We refer to repeatedly and/or\n  - Are subject to change.\n\nThese tend to be _settings_ like the paths to input and output files,\nand parameter values for programs.\nUsing variables makes it easier to change such settings.\nWe also need to understand variables to _work with loops and scripts_.\n\n### Assigning and referencing variables\n\n**To _assign_ a value to a variable** in the shell\n(in short: to assign a variable),\nuse the syntax `variable_name=value`:\n\n```bash\n# Assign the value \"beach\" to a variable with the name \"location\":\nlocation=beach\n\n# Assign the value \"200\" to a variable with the name \"n_lines\":\nn_lines=200\n```\n\n:::{.callout-warning}\n## There can be no spaces around the equals sign (`=`)!\n:::\n\n**To _reference_ a variable** (i.e., to access its value),\nyou need to put a dollar sign `$` in front of its name.\nAs before with the environment variable `$HOME`,\nwe'll use the `echo` command to see what values our variables contain:\n\n```bash\necho $location\n```\n```{.bash-out}\nbeach\n```\n\n```bash\necho $n_lines\n```\n```{.bash-out}\n200\n```\n\nConveniently, we can use variables in lots of contexts,\n**as if we had directly typed their _values_**:\n\n```bash\ninput_file=data/fastq/ASPC1_A178V_R1.fastq.gz\nls -lh $input_file \n```\n```{.bash-out}\n-rw-r--r-- 1 jelmer PAS0471 4.1M Aug  1 18:05 data/fastq/ASPC1_A178V_R1.fastq.gz\n```\n\n::: {.callout-note}\n#### Rules and tips for naming variables\n\nVariable names:\n\n- **Can** contain letters, numbers, and underscores\n- **Cannot** contain spaces, periods, or other special symbols\n- **Cannot start** with a number\n\nTry to make your variable names descriptive,\nlike `$input_file` above, as opposed to say `$x` and `$myvar`.\n\nThere are multiple ways of distinguishing words in the absence of spaces,\nsuch as `$inputFile` and `$input_file`:\nI prefer the latter, which is called \"snake case\".\n:::\n\n<br>\n\n### Quoting variables\n\nAbove, we learned that a variable name cannot contain spaces.\nBut what happens if our variable's _value_ contains spaces?\nFirst off, when we try to **assign** the variable without using quotes,\nwe get an error:\n\n```bash\ntoday=Thu, Aug 18\n```\n``` {.bash-out}\nAug: command not found\n```\n\n:::{.callout-caution collapse=\"true\"}\n## Why do you think we got this error?\n\nThe shell tried to assign everything up to the first space (i.e., `Thu,`)\nto `today`.\nAfter that, since we used a space,\nit assumed the next word (`Aug`) was something else:\nspecifically, it interpreted that as a command.\n:::\n\nBut it works when we quote (with _double_ quotes, `\"...\"`)\nthe entire string that makes up the value:\n\n```bash\ntoday=\"Thu, Aug 18\"\necho $today\n```\n```{.bash-out}\nThu, Aug 18\n```\n\n----\n\nNow, let's try to **reference** this variable in another context.\nFor example, we can try make a new file with today's date:\n\n```bash\ncd sandbox\n\ntouch README_$today.txt\nls\n```\n```{.bash-out}\n# The output should include the following files:\n18.txt  \nAug  \nREADME_Thu,\n```\n\n:::{.callout-caution collapse=\"true\"}\n#### What went wrong _here_?\nAgain, the shell split the value of `$today` in 3 parts separated by a space\n(this is called \"field splitting\"): as a result, three files were created.\n:::\n\nLike with assignment,\nour problems can be avoided by **quoting a variable** when we reference it.\nThis tells the shell it shouldn't perform \"field splitting\" on the variable's value;\nput another way, it takes aways the special meaning of the space as a _separator_\nin the variable's value:\n\n```bash\ntouch README_\"$today\".txt\n\nls -1\n```\n```{.bash-out}\n# The output should include the following file:\nREADME_Thu, Aug 18.txt\n```\n\n**It is good practice to quote variables** when you reference them:\nit never hurts, and avoids unexpected surprises.\n\n:::{.callout-note collapse=\"true\"}\n#### Where does a variable name end? (Click to expand)\nAnother issue we can run into when we don't quote variables\nis that we can't explicitly define where a variable name ends\nwithin a longer string of text:\n\n```bash\necho README_$today_final.txt\n```\n```{.bash-out}\nREADME_.txt\n```\n\n:::{.callout-caution collapse=\"true\"}\n## What went wrong here? (Hint: check the coloring highlighting above)\n\n- Following a `$`, the shell will stop interpreting characters as being part\n  of the variable name only when it encounters a character that cannot be\n  part of a variable name, such as a space or a period.\n\n- Since variable names _can_ contain underscores, it will look for the variable\n  `$today_final`, which does not exist.\n  \n- Importantly, the shell **does not error out** when you reference a\n  non-existing variable -- it basically ignores it,\n  such that `README_$today_final.txt` becomes `README_.txt`,\n  as if we hadn't referenced any variable.\n:::\n\nQuoting solves this issue, too:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho README_\"$today\"_final.txt\n```\n:::\n\n```{.bash-out}\nREADME_Thu, Aug 18_final.txt\n```\n:::\n\n:::{.callout-note collapse=\"true\"}\n## Quoting as \"escaping\" special meaning & and double vs. single quotes (Click to expand)\n\nBy double-quoting a variable,\nwe are essentially escaping (or \"turning off\")\nthe default special meaning of the _space as a separator_,\nand are asking the shell to interpret it as a _literal space_.\n\nSimilarly, double quotes will escape other \"special characters\",\nsuch as shell wildcards. Compare:\n\n```bash\necho *     # This will echo/list all files in the current working dir (!)\n```\n```{.bash-out}\n18.txt Aug README_Thu, README_Thu, Aug 18.txt\n```\n\n```bash\necho \"*\"   # This will simply print the \"*\" character \n```\n```{.bash-out}\n*\n```\n\nHowever, as we saw above,\ndouble quotes **not** turn off the special meaning of `$`\n(which is to denote a string as a variable):\n\n```bash\necho \"$today\"      # Double quotes do not escape the special meaning of $\n```\n```{.bash-out}\nThu, Aug 18\n```\n\n...but **_single quotes_** will:\n\n```bash\necho '$today'     # Single quotes do escape the special meaning of $\n```\n```{.bash-out}\n$today\n```\n:::\n\n<br>\n\n## For loops\n\nLoops are a universal element of programming languages,\nand are used to repeat operations,\nsuch as when you want to run the same script or command for multiple files.\n\nHere, we'll only cover the **most common type of loop: the `for` loop.**\nThese _iterate_ over a collection, such as a list of files:\nthat is,\nthey allow you to perform one or more actions for each element in the collection,\none element at a time.\n\n### `for` loop syntax and mechanics\n\nLet's see a first example,\nwhere our \"collection\" is just a very short list of numbers (`1`, `2`, and `3`)\nthat we define on the fly:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nfor a_number in 1 2 3; do\n    echo \"In this iteration of the loop, the number is $a_number\"\n    echo \"--------\"\ndone\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\nIn this iteration of the loop, the number is 1\n--------\nIn this iteration of the loop, the number is 2\n--------\nIn this iteration of the loop, the number is 3\n--------\n```\n:::\n:::\n\n\nThe **indented lines** between `do` and `done` contain the code that is being executed\n_as many times as there are items in the collection_:\nin this case 3 times, as you can tell from the output above.\n\nOn the first and last, unindented lines,\n`for` loops contain the following mandatory keywords:\n\n| Keyword | Purpose\t                            |\n|---------|-------------------------------------|\n| `for`\t  | After `for`, we set the **variable name** (an arbitrary name; above we used `a_number`)\n| `in`\t  | After `in`, we specify the **collection** (list of items) we are looping over\t\n| `do`\t  | After `do`, we have one ore more lines specifying what to do with each item\t\n| `done`  | Tells the shell we are done with the loop \n\n:::{.callout-note collapse=\"true\"}\n## A semicolon `;` (as used before `do`) separates two commands on a single line (Click to expand)\n\nA semicolon separates two commands written on a single line --\nfor instance, instead of:\n\n```bash\nmkdir results\ncd results\n```\n\n...you could equivalently type:\n\n```bash\nmkdir results; cd results\n```\n\nThe `;` in the `for` loop syntax has the same function, and as such,\nan alternative way to format a `for` loop is:\n\n```bash\nfor a_number in 1 2 3\ndo\n    echo \"In this iteration of the loop, the number is $a_number\"\ndone\n```\n\nBut that's one line longer and a bit awkwardly asymmetric.\n:::\n\n<br>\n\n----\n\nHere are two key things about `for` loops that we touched on above\nbut are worth digging into a but more:\n\nFirst, in each iteration of the loop, one element in the collection\n**is being assigned to the variable** specified after `for`.\nIn the example above, we used `a_number` as the variable name,\nso that variable contained `1` when the loop ran for the first time,\n`2` when it ran for the second time,\nand `3` when it ran for the third and last time.\n\nThis variable continues to exist outside of the loop,\nand will have the last value that was assigned to it in the loop:\n\n```bash\necho $a_number\n```\n::: {.bash-out}\n3\n:::\n\nSecond, **the loop runs sequentially for each item in the collection**,\nand will run exactly as many times as there are items in the collection.\n\nThe following example, where we let the computer sleep for 1 second\nbefore printing the date and time with the `date` command,\ndemonstrates that the loop is being executed sequentially (not in parallel).\nWhen you run it,\nyou should notice a slight pause after the output of each iteration is printed,\nand you can see that the output of `date` differs by one second each time:\n\n```bash\nfor a_number in 1 2 3; do\n    echo \"In this iteration of the loop, the number is $a_number\"\n    date              # Print the date and time\n    echo \"--------\"\n    sleep 1           # Let the computer sleep for 1 second\ndone\n```\n```{.bash-out}\nIn this iteration of the loop, the number is 1  \nTue Aug 15 13:30:16 EDT 2023  \n--------  \nIn this iteration of the loop, the number is 2  \nTue Aug 15 13:30:17 EDT 2023  \n--------  \nIn this iteration of the loop, the number is 3  \nTue Aug 15 13:30:18 EDT 2023  \n```\n\n:::{.exercise}\n### On Your Own: A simple loop {-}\n\nCreate a loop that will print:\n\n```{.bash-out}\nmorel is an Ohio mushroom  \ndestroying_angel is an Ohio mushroom  \neyelash_cup is an Ohio mushroom\n```\n\n:::{.callout-tip collapse=\"true\"}\n## Hints (Click to expand)\n\n- Just like we looped over 3 numbers above (`1`, `2`, and `3`),\n  you want to loop over the three mushroom names,\n  `morel`, `destroying_angel`, and `eyelash_cup`.\n\n- Notice that when we specify the collection \"manually\",\n  like we did above with numbers, the elements are simply separated by a space.\n:::\n\n:::{.callout-tip collapse=\"true\"}\n## Solution (Click to expand)\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nfor mushroom in morel destroying_angel eyelash_cup; do\n    echo \"$mushroom is an Ohio mushroom\"\ndone\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\nmorel is an Ohio mushroom\ndestroying_angel is an Ohio mushroom\neyelash_cup is an Ohio mushroom\n```\n:::\n:::\n\n\n:::\n:::\n\n<br>\n\n### Looping over files with globbing\n\nIn practice, it is rare to manually list the collection of items we want to\nloop over,\nlike we did above with the numbers 1-3 and a few types of mushroom in the\nexercise.\nInstead, we commonly **loop over files directly** using _globbing_: \n\n```bash\ncd /fs/ess/PAS0471/$USER/rnaseq_intro\n\nfor fastq_file in data/fastq/*fastq.gz; do\n    echo \"Now processing FASTQ file $fastq_file...\"\n    # [Code to analyze the FASTQ file...]\ndone\n```\n```{.bash-out}\nNow processing FASTQ file data/fastq/ASPC1_A178V_R1.fastq.gz...\nNow processing FASTQ file data/fastq/ASPC1_A178V_R2.fastq.gz...\nNow processing FASTQ file data/fastq/ASPC1_G31V_R1.fastq.gz...\nNow processing FASTQ file data/fastq/ASPC1_G31V_R2.fastq.gz...\nNow processing FASTQ file data/fastq/Miapaca2_A178V_R1.fastq.gz...\nNow processing FASTQ file data/fastq/Miapaca2_A178V_R2.fastq.gz...\nNow processing FASTQ file data/fastq/Miapaca2_G31V_R1.fastq.gz...\nNow processing FASTQ file data/fastq/Miapaca2_G31V_R2.fastq.gz...\n```\n\n**This technique is extremely useful**.\nTake a moment to realize that we're not doing a separate `ls` and storing\nthe results:\nas mentioned before, a globbing pattern directly selects files.\n\nIf needed,\nyou can use your globbing / wild card skills to narrow down the file selection:\n\n- Perhaps we only want to select R1 files (forward reads): \n\n  ```bash\n  for fastq_file in data/raw/*_R1.fastq.gz; do\n      # [Some file processing...]\n  done\n  ```\n\n- Or our FASTQ files are tucked away in sample-specific folders:\n\n  ```bash\n  # With default shell settings, '**' will traverse one dir level\n  # E.g., files are in 'results/trim/sampleA/', 'results/trim/sampleB/', etc. \n  for fastq_file in results/trim/**/*_R1.fastq.gz; do\n      # [Some file processing...]\n  done\n  ```\n\n<br>\n\n## At-home reading: Command substitution\n\nIf you want to store the result of a command in a variable,\nyou can use a construct called \"**command substitution**\"\nby wrapping the command inside `$()`.\n\nLet's see an example.\nAs you know, the `date` command will print the current date and time:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ndate\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\nWed Aug 23 09:51:37 EDT 2023\n```\n:::\n:::\n\n\nIf we try to store the date in a variable directly, it doesn't work:\nthe literal string \"date\" is stored, not the output of the command:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ntoday=date\necho \"$today\"\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\ndate\n```\n:::\n:::\n\n\nThat's why we need command substitution with `$()`:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ntoday=$(date)\necho \"$today\"\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\nWed Aug 23 09:51:37 EDT 2023\n```\n:::\n:::\n\n\n----\n\nOne practical example of using command substitution is when you want to\nautomatically  include the current date in a file name.\nFirst, note that we can use `date +%F` to print the date in `YYYY-MM-DD` format,\nand omit the time:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ndate +%F\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\n2023-08-23\n```\n:::\n:::\n\n\nLet's use that in a command substitution &mdash; but a bit differently than before:\nwe use the command substitution `$(date +%F)` _directly_ in our\n`touch` command, rather than first assigning it to a variable:\n\n```bash\ncd sandbox\n\n# Create a file with our $today variable:\ntouch README_\"$(date +%F)\".txt\n\nls\n```\n```{.bash-out}\n# Output should include a file like this (the actual date will vary, of course!):\nREADME_2023-08-15.txt\n```\n\nAmong many other uses,\ncommand substitution is handy when you want your script to report some results,\nor when a next step in the script depends on a previous result.\nWe'll come across it a few times in our shell scripts later on.\n\n:::{.exercise}\n### On Your Own: Command substitution {-}\n\nSay we wanted to store and report the number of lines in a FASTQ file,\nwhich, as discussed before, tells us how many reads are in it\n(there are 4 lines per read).\n\nAs we've also seen before, `wc -l` gets you the number of lines,\nand if you pipe input into `wc -l`, it won't include the filename &mdash;\nthis is useful for what you'll want to do below:\n\n```bash\ncd /fs/ess/PAS0471/$USER/rnaseq_intro\n\nzcat data/fastq/ASPC1_A178V_R1.fastq.gz | wc -l\n```\n```{.bash-out}\n400000\n```\n\n**Use command substitution to store the output of the last command in a variable,**\n**and then use an `echo` command to print:**\n\n```{bash-out}\nThe file has 30387 lines\n```\n\n:::{.callout-tip collapse=\"true\"}\n## Solution\n\n```bash\nn_lines=$(zcat data/fastq/ASPC1_A178V_R1.fastq.gz | wc -l)\necho \"The file $n_lines lines\"\n```\n```{.bash-out}\nThe file 400000 lines\n```\n\n**Note:** You don't have to quote variables _inside_ a quoted `echo` call,\nsince it's, well, already quoted.\nIf you _also_ quote the variables, you will in fact _unquote_ it,\nalthough that shouldn't pose a problem inside echo statements.\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}