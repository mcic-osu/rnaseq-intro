{
  "hash": "e13e4d9a7f30f9cac794f8901833fa45",
  "result": {
    "markdown": "---\ntitle: \"Variables, Globbing, and Loops\"\npagetitle: \"Variables, Globbing, and Loops\"\nhighlight-style: github\nnumber-sections: true\nknitr:\n  opts_knit:\n    root.dir: \"sandbox\"\nauthor: Jelmer Poelstra\n---\n\n::: {.cell}\n\n:::\n\n\n-----\n\nIn this module, we will cover a few topics that are good to know about\nbefore you start writing and running shell scripts:\n\n- Using **variables** will allow you to run scripts flexibly,\n  with different input files and settings.\n\n- **`for` loops** will allow you to repeat operations &mdash;\n  specifically, we will later use them to submit many scripts at the same time,\n  one per input file or sample.\n\n<br>\n\n## Setup\n\n**Starting a VS Code session with an active terminal:**\n\n1. Log in to OSC at <https://ondemand.osc.edu>.\n2. In the blue top bar, select `Interactive Apps` and then `Code Server`.\n3. In the form that appears:\n   - Enter `4` or more in the box `Number of hours`\n   - **To avoid having to switch folders within VS Code**,\n     enter `/fs/ess/scratch/PAS2250/participants/<your-folder>` in the box `Working Directory`\n     (replace `<your-folder>` by the actual name of your folder).\n   - Click `Launch`.\n4. On the next page,\n   once the top bar of the box is green and says `Runnning`,\n   click `Connect to VS Code`.\n5. Open a terminal: {{< fa bars >}} &nbsp; => `Terminal` => `New Terminal`.\n6. In the terminal, type `bash` and press <kbd>Enter</kbd>.\n7. Type `pwd` in the termain to check you are in `/fs/ess/scratch/PAS2250`.\n   \n   If not, click\n   {{< fa bars >}} &nbsp; => &nbsp; `File` &nbsp; => &nbsp; `Open Folder`\n   and enter `/fs/ess/scratch/PAS2250/<your-folder>`.\n\n<br>\n\n## Variables\n\nIn programming, we use **variables** for things that:\n\n  - We refer to repeatedly and/or\n  - Are subject to change.\n\nThese tend to be _settings_ like the paths to input and output files,\nand parameter values for programs.\n\nUsing variables makes it easier to change such settings.\nWe also need to understand variables to work with loops and with scripts.\n\n### Assigning and referencing variables\n\n**To _assign_ a value to a variable in Bash** (in short: to assign a variable),\nuse the syntax `variable=value`:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# Assign the value \"beach\" to the variable \"location\":\nlocation=beach\n\n# Assign the value \"200\" to the variable \"nlines\":\nnlines=200\n```\n:::\n\n\n:::{.callout-warning}\n## Be aware: don't put spaces around the equals sign (`=`)!\n:::\n\n**To _reference_ a variable** (i.e., to access its value),\nyou need to put a dollar sign `$` in front of its name.\nWe'll use the `echo` command to review the values that our variables contain:\n\n:::{.callout-note}\n## `echo` simply prints back (\"echoes\") whatever you tell it to\n\n::: {.cell}\n\n```{.bash .cell-code}\necho Hello!\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\nHello!\n```\n:::\n:::\n\n:::\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho $location\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\nbeach\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\necho $nlines\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\n200\n```\n:::\n:::\n\n\nConveniently, we can directly use variables in lots of contexts,\n**as if we had instead typed their _values_**:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ninput_file=data/fastq/SRR7609467.fastq.gz\n\nls -lh $input_file \n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\n-rw-r--r--@ 1 poelstra.1  staff   8.3M Jul 16 16:12 data/fastq/SRR7609467.fastq.gz\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\nls_options=\"-lh\"            # (We'll talk about the quotes that are used here later)\n\nls $ls_options data/meta\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\ntotal 8\n-rw-r--r--@ 1 poelstra.1  staff   583B Jul 16 16:12 meta.tsv\n```\n:::\n:::\n\n\n<br>\n\n### Rules and tips for naming variables\n\nVariable names:\n\n- **Can** contain letters, numbers, and underscores\n- **Cannot** contain spaces, periods, or other special symbols\n- **Cannot start** with a number\n\nTry to make your variable names descriptive,\nlike `$input_file` and `$ls_options` above, as opposed to say `$x` and `$bla`.\n\nThere are multiple ways of distinguishing words in the absence of spaces,\nsuch as `$inputFile` and `$input_file`:\nI prefer the latter, which is called \"snake case\", and I always use lowercase.\n\n<br>\n\n### Quoting variables\n\nAbove, we learned that a variable name cannot contain spaces.\nBut what happens if our variable's _value_ contains spaces?\nFirst off, when we try to **assign** the variable without using quotes,\nwe get an error:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ntoday=Thu, Aug 18\n```\n:::\n\n\n:::{.bash-out}\nAug: command not found\n:::\n\n:::{.callout-caution collapse=\"true\"}\n## Why do you think we got this error?\n\nBash tried assign everything up to the first space (i.e., `Thu,`)\nto `today`.\nAfter that, since we used a space,\nit assumed the next word (`Aug`) was something else:\nspecifically, another command.\n:::\n\nBut it works when we quote (with _double_ quotes, `\"...\"`)\nthe entire string that makes up the value:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ntoday=\"Thu, Aug 18\"\necho $today\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\nThu, Aug 18\n```\n:::\n:::\n\n\n----\n\nNow, let's try to **reference** this variable in another context.\nNote that the **`touch`** command can create new files,\ne.g. `touch a.txt` creates the file `a.txt`.\nSo let's try make a new file with today's date:\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\ntouch README_$today.txt\nls\n```\n:::\n\n\n:::{.bash-out}\n18.txt  \nAug  \nREADME_Thu,\n::::\n\n:::{.callout-caution collapse=\"true\"}\n## What went wrong here?\n\nThe shell performed so-called _field splitting_ using spaces as a separator,\nsplitting the value into three separate units &ndash;\nas a result, three files were created.\n\n:::\n\nLike with assignment,\nour problems can be avoided by **quoting a variable** when we reference it:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ntouch README_\"$today\".txt\n\n# This will list the most recently modified file (ls -t sorts by last modified date):\nls -t | head -n 1\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\nREADME_Thu, Aug 18.txt\n```\n:::\n:::\n\n\n**It is good practice to quote variables** when you reference them:\nit never hurts, and avoids unexpected surprises.\n\n:::{.callout-note collapse=\"true\"}\n## At-home reading: Where does a variable name end?\n\nAnother issue we can run into when we don't quote variables\nis that we can't explicitly define where a variable name ends\nwithin a longer string of text:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho README_$today_final.txt\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\nREADME_.txt\n```\n:::\n:::\n\n\n:::{.callout-caution collapse=\"true\"}\n## What went wrong here? (Hint: check the coloring highlighting above)\n\n- Following a `$`, the shell will stop interpreting characters as being part\n  of the variable name only when it encounters a character that cannot be\n  part of a variable name, such as a space or a period.\n\n- Since variable names _can_ contain underscores, it will look for the variable\n  `$today_final`, which does not exist.\n  \n- Importantly, the shell **does not error out** when you reference a\n  non-existing variable -- it basically ignores it,\n  such that `README_$today_final.txt` becomes `README_.txt`,\n  as if we hadn't referenced any variable.\n\n:::\n\nQuoting solves this issue, too:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho README_\"$today\"_final.txt\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\nREADME_Thu, Aug 18_final.txt\n```\n:::\n:::\n\n\n:::\n\n:::{.callout-note collapse=\"true\"}\n## At-home reading: Quoting as \"escaping\" special meaning -- and double vs. single quotes\n\nBy double-quoting a variable,\nwe are essentially escaping (or \"turning off\")\nthe default special meaning of the _space as a separator_,\nand are asking the shell to interpret it as a _literal space_.\n\nSimilarly, we are escaping other \"special characters\",\nsuch as globbing wildcards, with double quotes. Compare:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho *     # This will echo/list all files in the current working dir (!)\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\n18.txt Aug README_Thu, README_Thu, Aug 18.txt data sandbox scripts\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\necho \"*\"   # This will simply print the \"*\" character \n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\n*\n```\n:::\n:::\n\n\nHowever, as we saw above,\ndouble quotes _do not_ turn off the special meaning of `$`\n(denoting a string as a variable):\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho \"$today\"\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\nThu, Aug 18\n```\n:::\n:::\n\n\n...but **_single quotes_** will:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho '$today'\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\n$today\n```\n:::\n:::\n\n\n:::\n\n<br>\n\n### Command substitution\n\nIf you want to store the result of a command in a variable,\nyou can use a construct called \"**command substitution**\"\nby wrapping the command inside `$()`.\n\nLet's see an example.\nThe `date` command will print the current date and time:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ndate\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\nTue Aug  1 21:36:24 EDT 2023\n```\n:::\n:::\n\n\nIf we try to store the date in a variable directly, it doesn't work:\nthe literal string \"date\" is stored, not the output of the command:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ntoday=date\necho \"$today\"\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\ndate\n```\n:::\n:::\n\n\nThat's why we need command substitution with `$()`:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ntoday=$(date)\necho \"$today\"\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\nTue Aug  1 21:36:24 EDT 2023\n```\n:::\n:::\n\n\n----\n\nIn practice, you might use command substitution with `date` to include the\ncurrent date in files.\nTo do so, first, note that we can use `date +%F` to \nprint the date in `YYYY-MM-DD` format, and omit the time:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ndate +%F\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\n2023-08-01\n```\n:::\n:::\n\n\nLet's use that in a command substitution &mdash; but a bit differently than before:\nwe use the command substitution `$(date +%F)` _directly_ in our\n`touch` command, rather than first assigning it to a variable:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# Create a file with our $today variable:\ntouch README_\"$(date +%F)\".txt\n\n# Check the name of our newly created file:\nls -t | head -n 1\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\nREADME_2023-08-01.txt\n```\n:::\n:::\n\n\nAmong many other uses,\ncommand substitution is handy when you want your script to report some results,\nor when a next step in the script depends on a previous result.\n\n:::{.exercise}\n\n### On Your Own: Command substitution {-}\n\nSay we wanted to store and report the number of lines in a file,\nwhich can be a good QC measure for FASTQ and other genomic data files.\n\n`wc -l` gets you the number of lines,\nand you can use a trick to omit the filename:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nwc -l data/fastq/SRR7609472.fastq.gz\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\n   30387 data/fastq/SRR7609472.fastq.gz\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\n# Use `<` (input redirection) to omit the filename:\nwc -l < data/fastq/SRR7609472.fastq.gz\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\n   30387\n```\n:::\n:::\n\n\n**Use command substitution to store the output of the last command in a variable,**\n**and then use an `echo` command to print:**\n\n```{bash-out}\nThe file has 30387 lines\n```\n\n:::{.callout-tip collapse=\"true\"}\n## Solution\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nnlines=$(wc -l < data/fastq/SRR7609472.fastq.gz)\n\necho \"The file $nlines lines\"\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\nThe file    30387 lines\n```\n:::\n:::\n\n\n**Note:** You don't have to quote variables _inside_ a quoted `echo` call,\nsince it's, well, already quoted.\nIf you _also_ quote the variables, you will in fact _unquote_ it,\nalthough that shouldn't pose a problem inside echo statements.\n\n:::\n:::\n\n<br>\n\n## For loops\n\nLoops are a universal element of programming languages,\nand are used to repeat operations,\nsuch as when you want to run the same script or command for multiple files.\n\n**Here, we'll only cover what is by far the most common type of loop:\nthe `for` loop.**\n\n`for` loops _iterate_ over a collection, such as a list of files:\nthat is, they allow you to perform one or more actions for each element in the collection, one element at a time.\n\n### `for` loop syntax and mechanics\n\nLet's see a first example,\nwhere our \"collection\" is just a very short list of numbers (`1`, `2`, and `3`):\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nfor a_number in 1 2 3; do\n    echo \"In this iteration of the loop, the number is $a_number\"\n    echo \"--------\"\ndone\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\nIn this iteration of the loop, the number is 1\n--------\nIn this iteration of the loop, the number is 2\n--------\nIn this iteration of the loop, the number is 3\n--------\n```\n:::\n:::\n\n\n`for` loops contain the following mandatory keywords:\n\n| Keyword   | Purpose\t\n|-----------|-------------\n| `for`\t    | After `for`, we set the variable name\t\n| `in`\t    | After `in`, we specify the collection we are looping over\t\n| `do`\t    | After `do`, we have one ore more lines specifying what to do with each item\t\n| `done`\t  | Tells the shell we are done with the loop\n\n\n:::{.callout-caution collapse=\"true\"}\n## A semicolon `;` (as used before `do`) separates two commands on a single line\n\nA semicolon separates two commands written on a single line --\nfor instance, instead of:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nmkdir results\ncd results\n```\n:::\n\n\n...you could equivalently type:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nmkdir results; cd results\n```\n:::\n\n\nThe `;` in the `for` loop syntax has the same function, and as such,\nan alternative way to format a `for` loop is:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nfor a_number in 1 2 3\ndo\n    echo \"In this iteration of the loop, the number is $a_number\"\ndone\n```\n:::\n\n\nBut that's one line longer and a bit awkwardly asymmetric.\n\n:::\n\nThe aspect that is perhaps most difficult to understand is that in each iteration\nof the loop, one element in the collection (in the example above, either `1`,\n`2`, or `3`) **is being assigned** to the variable specified after `for`\n(in the example above, `a_number`).\n\n----\n\nIt is also important to realize that\n**the loop runs sequentially for each item in the collection**,\nand will run exactly as many times as there are items in the collection.\n\nThe following example, where we let the computer sleep for 1 second\nbefore printing the date and time with the `date` command,\ndemonstrates that the loop is being executed sequentially:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nfor a_number in 1 2 3; do\n    echo \"In this iteration of the loop, the number is $a_number\"\n    sleep 1s          # Let the computer sleep for 1 second\n    date              # Print the date and time\n    echo \"--------\"\ndone\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\nIn this iteration of the loop, the number is 1\nusage: sleep seconds\nTue Aug  1 21:36:24 EDT 2023\n--------\nIn this iteration of the loop, the number is 2\nusage: sleep seconds\nTue Aug  1 21:36:24 EDT 2023\n--------\nIn this iteration of the loop, the number is 3\nusage: sleep seconds\nTue Aug  1 21:36:24 EDT 2023\n--------\n```\n:::\n:::\n\n\n:::{.exercise}\n\n### On Your Own: A simple loop {-}\n\nCreate a loop that will print:\n\n```{bash-out}\nmorel is an Ohio mushroom  \ndestroying_angel is an Ohio mushroom  \neyelash_cup is an Ohio mushroom\n```\n\n:::{.callout-tip collapse=\"true\"}\n## Hints\n\n- Just like we looped over 3 numbers above (`1`, `2`, and `3`),\n  you want to loop over the three mushroom names,\n  `morel`, `destroying_angel`, and `eyelash_cup`.\n\n- Notice that when we specify the collection \"manually\",\n  like we did above with numbers, the elements are simply separated by a space.\n:::\n\n:::{.callout-tip collapse=\"true\"}\n## Solution\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nfor mushroom in morel destroying_angel eyelash_cup; do\n    echo \"$mushroom is an Ohio mushroom\"\ndone\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\nmorel is an Ohio mushroom\ndestroying_angel is an Ohio mushroom\neyelash_cup is an Ohio mushroom\n```\n:::\n:::\n\n\n:::\n:::\n\n<br>\n\n### Looping over files with globbing\n\nIn practice, we rarely manually list the collection of items we want to\nloop over.\nInstead, we commonly **loop over files** directly using _globbing_: \n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# We make sure we only select gzipped FASTQ files using the `*fastq.gz` glob\nfor fastq_file in data/raw/*fastq.gz; do\n    echo \"File $fastq_file has $(wc -l < $fastq_file) lines.\"\n    # More processing...\ndone\n```\n:::\n\n\n**This technique is extremely useful**, and I use it all the time.\nTake a moment to realize that we're not doing a separate `ls` and storing\nthe results:\nas mentioned, we can _directly_ use a globbing pattern to select our files.\n\nIf needed,\nyou can use your globbing / wild card skills to narrow down the file selection:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# Perhaps we only want to select R1 files (forward reads): \nfor fastq_file in data/raw/*R1*fastq.gz; do\n    # Some file processing...\ndone\n\n# Or only filenames starting with A or B:\nfor fastq_file in data/raw/[AB]*fastq.gz; do\n    # Some file processing...\ndone\n```\n:::\n\n\n:::{.callout-note  collapse=\"true\"}\n## At-home reading: Alternatives to looping with a glob\n\nWith genomics data,\nthe routine of looping over an entire directory of files,\nor selections made with simple globbing patterns,\nshould serve you very well.\n\nBut in some cases,\nyou may want to iterate only over a specific list of filenames\n(or partial filenames such as sample IDs)\nthat represent a complex selection.\n\n- If this is a **short list**, you could directly specify it in the loop:\n\n\n  ::: {.cell}\n  \n  ```{.bash .cell-code}\n  for sample in A1 B6 D3; do\n      R1=data/fastq/\"$sample\"_R1.fastq.gz\n      R2=data/fastq/\"$sample\"_R2.fastq.gz\n      # Some file processing...\n  done\n  ```\n  :::\n\n\n- If it is a **longer list**,\n  you could create a simple text file with one line per sample ID / filename,\n  and use command substitution as follows:\n\n\n  ::: {.cell}\n  \n  ```{.bash .cell-code}\n  for fastq_file in $(cat file_of_filenames.txt); do\n      # Some file processing...\n  done\n  ```\n  :::\n\n\nIn cases like this, _Bash arrays_\n(basically, variables that consist of multiple values, like a vector in R)\nor _`while` loops_ may provide more elegant solutions,\nbut those are outside the scope of this introduction.\n\n:::\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}