{
  "hash": "f38c285ba4329533698ac04a8606cac4",
  "result": {
    "markdown": "---\ntitle: \"Batch Jobs in Practice\"\nsubtitle: \"Practical examples of writing shell scripts and running them as batch jobs at OSC\"\npagetitle: \"Batch Jobs in Practice\"\nhighlight-style: github\nnumber-sections: true\nauthor:\n  - Jelmer Poelstra\n  - Mike Sovic\n---\n\n::: {.cell}\n\n:::\n\n\n-----\n\nSo far,\nwe have covered all the building blocks to be able to run command-line programs\nat OSC:\n\n- Basics of a supercomputer and of OSC specifically\n- Bash shell basics to work at a supercomputer,\n  and learn the language used in our scripts\n- The bells and whistles needed to turn our commands into a shell script\n- Loading and installing the software (command-line programs) that we want to run\n- Working with the Slurm job scheduler, so we can submit scripts as batch jobs\n- The ability to loop over commands, so that we can submit many scripts at once\n\nWith these skills, it's relatively straightforward to create and submit scripts\nto run most command-line programs that can analyze our genomics data.\n\nOf course, how straightforward this exactly is depends on the ease of use of\nthe programs you need to run, but that will be true in general whenever you\nlearn a new approach and the associated software.\n\n<br>\n\n## Setup\n\n:::{.callout-note collapse=\"true\"}\n## Starting a VS Code session with an active terminal (click here)\n\n1. Log in to OSC at <https://ondemand.osc.edu>.\n2. In the blue top bar, select `Interactive Apps` and then `Code Server`.\n3. In the form that appears:\n   - Enter `4` or more in the box `Number of hours`\n   - **To avoid having to switch folders within VS Code**,\n     enter `/fs/ess/scratch/PAS2250/participants/<your-folder>` in the box `Working Directory`\n     (replace `<your-folder>` by the actual name of your folder).\n   - Click `Launch`.\n4. On the next page,\n   once the top bar of the box is green and says `Runnning`,\n   click `Connect to VS Code`.\n5. Open a terminal: {{< fa bars >}} &nbsp; => `Terminal` => `New Terminal`.\n6. In the terminal, type `bash` and press <kbd>Enter</kbd>.\n7. Type `pwd` in the termain to check you are in `/fs/ess/scratch/PAS2250`.\n   \n   If not, click\n   {{< fa bars >}} &nbsp; => &nbsp; `File` &nbsp; => &nbsp; `Open Folder`\n   and enter `/fs/ess/scratch/PAS2250/<your-folder>`.\n:::\n\n<br>\n\n## Worked example, part I: A script to run FastQC\n\n### FastQC: A program for quality control of FASTQ files \n\nFastQC is perhaps the most ubiquitous genomics software.\nIt produces visualizations and assessments of FASTQ files for statistics\nsuch as per-base quality (below) and adapter content.\nRunning FastQC should, at least for Illumina data,\nalmost always be the first analysis step after receiving your sequences.  \n\nFor each FASTQ file, FastQC outputs an HTML file that you can open in your\nbrowser and which has about a dozen graphs showing different QC metrics.\nThe most important one is the per-base quality score graph shown below.\n\n:::{.callout-note collapse=\"true\"}\n## A FastQC quality score graph for decent-quality reads\n\n<p align=\"center\">\n<img src=img/fastqc_good.png width=\"85%\">\n</p>\n:::\n\n:::{.callout-note collapse=\"true\"}\n## A FastQC quality score graph for poor-quality reads\n\n<p align=\"center\">\n<img src=img/fastqc_bad.png width=\"85%\">\n</p>\n:::\n\n<br>\n\n### FastQC syntax\n\nTo analyze one optionally gzipped FASTQ file with FastQC,\nthe syntax is simply:\n  \n\n::: {.cell}\n\n```{.bash .cell-code}\nfastqc <fastq-file>\n```\n:::\n\n\nOr if we wanted to specify the output directory\n(otherwise, output files end up in the current working directory):\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nfastqc --outdir=<output-dir> <fastq-file>\n```\n:::\n\n\nFor instance, if we wanted output files to go to the directory `results/fastqc`\nand wanted the program to analyze the file `data/fastq/SRR7609467.fastq.gz`,\na functional command would like like this:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nfastqc --outdir=results/fastqc data/fastq/SRR7609467.fastq.gz\n```\n:::\n\n\n:::{.callout-tip}\n## FastQC's output file names are automatically determined\nWe can specify the output _directory_, but not the actual file names,\nwhich will be automatically determined by FastQC based on the input file name.\n\nFor one FASTQ file, it will output one HTML file and one ZIP archive.\nThe latter contains files with the summary statistics that were computed and\non which the figures are based &mdash; we generally don't need to look at that.\n:::\n\n<br>\n\n### A basic FastQC script\n\nHere is what a basic script to run FastQC could look like:\n  \n\n::: {.cell}\n\n```{.bash .cell-code}\n#!/bin/bash\n\n## Bash strict settings\nset -euo pipefail\n\n## Copy the placeholder variables\ninput_file=\"$1\"\noutput_dir=\"$2\" \n\n## Run FastQC\nfastqc --outdir=\"$output_dir\" \"$input_file\"\n```\n:::\n\n\nBut we'll add a few things to to run this script smoothly as a batch job at OSC:\n\n- We load the relevant OSC module:\n\n\n  ::: {.cell}\n  \n  ```{.bash .cell-code}\n  module load fastqc/0.11.8\n  ```\n  :::\n\n  \n- We add a few `sbatch` options:\n\n\n  ::: {.cell}\n  \n  ```{.bash .cell-code}\n  #SBATCH --account=PAS2250\n  #SBATCH --output=slurm-fastqc-%j.out\n  ```\n  :::\n\n\nWe'll also add a few `echo` statements to report what's going on,\nand use a trick we haven't yet seen &mdash;\ncreating the output directory but only if it doesn't yet exist:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nmkdir -p \"$output_dir\"\n```\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n## The `-p` option for `mkdir`\n\nUsing the `-p` option does two things at once for us,\nboth of which are necessary for a foolproof inclusion of this command\nin a script:\n\n- It will enable `mkdir` to create multiple levels of directories at once:\n  by default, `mkdir` errors out if the _parent_ directory/directories of the\n  specified directory don't yet exist.\n\n\n  ::: {.cell}\n  \n  ```{.bash .cell-code}\n  mkdir newdir1/newdir2\n  #> mkdir: cannot create directory ‘newdir1/newdir2’: No such file or directory\n  ```\n  :::\n\n  ::: {.cell}\n  \n  ```{.bash .cell-code}\n  mkdir -p newdir1/newdir2    # This successfully creates both directories\n  ```\n  :::\n\n\n- If the directory already exists, it won't do anything and won't return an error\n  (which would lead the script to abort at that point with our `set` settings).\n  \n\n  ::: {.cell}\n  \n  ```{.bash .cell-code}\n  mkdir newdir1/newdir2\n  #> mkdir: cannot create directory ‘newdir1/newdir2’: File exists\n  ```\n  :::\n\n  ::: {.cell}\n  \n  ```{.bash .cell-code}\n  mkdir -p newdir1/newdir2   # This does nothing since the dirs already exist\n  ```\n  :::\n\n:::\n\nOur script now looks as follows:\n\n:::{.callout-note collapse=\"true\"}\n## Click here to see the script\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n#!/bin/bash\n#SBATCH --account=PAS2250\n#SBATCH --output=slurm-fastqc-%j.out\n  \n## Bash strict settings\nset -euo pipefail\n\n## Load the software\nmodule load fastqc\n\n## Copy the placeholder variables\ninput_file=\"$1\"\noutput_dir=\"$2\" \n\n## Initial reporting\necho \"Starting FastQC script\"\ndate\necho \"Input FASTQ file:   $input_file\"\necho \"Output dir:         $output_dir\"\necho\n\n## Create the output dir if needed\nmkdir -p \"$output_dir\"\n\n## Run FastQC\nfastqc --outdir=\"$output_dir\" \"$input_file\"\n\n## Final reporting\necho\necho \"Listing output files:\"\nls -lh \"$output_dir\"\n\necho\necho \"Done with FastQC script\"\ndate\n\n```\n:::\n\n\n:::\n\nNotice that this script is very similar to our toy scripts from yesterday\nand today:\nmostly standard (\"boilerplate\") code with\n**just a single command to run our program of interest.**\n\nTherefore, you can adopt this script as a template for scripts that run other\ncommand-line programs, and will generally only need minor modifications!\n\n:::{.callout-tip collapse=\"true\"}\n## Keep your scripts simple -- use one program in a script\n\nIn general, it is a good idea to keep your scripts simple and run one program\nper script.\n\nOnce you get the hang of it, it may seem appealing to string a number of programs\ntogether in a single script, so that it's easier to rerun everything &mdash;\nbut that will often end up leading to more difficulties than convenience. \n\nTo really tie your full set of analyses together in an _actual_\nworkflow / pipeline, you will want to start using a workflow management system\nlike [Snakemake](https://snakemake.readthedocs.io/en/stable/) or\n[NextFlow](https://www.nextflow.io/).\n:::\n\n<br>\n\n### Submitting our FastQC script as a batch job\n\nOpen a new file in VS Code\n(&nbsp; {{< fa bars >}} &nbsp; => &nbsp; `File` &nbsp; => &nbsp; `New File`)\nand save it as `fastqc.sh` within your `scripts/` directory.\nPaste in the code above and save the file.\n\nThen, we submit the script:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nsbatch scripts/fastqc.sh data/fastq/SRR7609467.fastq.gz results/fastqc\n```\n:::\n\n\n:::{.bash-out}\nSubmitted batch job 12521308\n:::\n\n:::{.callout-caution collapse=\"true\"}\n### Once again: Where does our output go?\n\n- Output that would have been printed to screen if we had run the script directly:\n  in the Slurm log file `slurm-fastqc-<job-nr>.out`\n  \n- FastQC's main output files (HTML ZIP): to the output directory we specified.\n:::\n\nLet's take a look at the queue:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nsqueue -u $USER\n# Fri Aug 19 10:38:16 2022\n#              JOBID PARTITION     NAME     USER    STATE       TIME TIME_LIMI  NODES NODELIST(REASON)\n#           12521308 serial-40 fastqc.s   jelmer  PENDING       0:00   1:00:00      1 (None)\n```\n:::\n\n\nOnce it's no longer in the list produced by `squeue`, it's done.\nThen,  let's check the Slurm log file[^1]:\n\n[^1]: For longer running jobs,\n      you may also want to keep an eye on the log file while it's running.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncat slurm-fastqc-12521308.out    # You'll have a different number in the file name\n```\n:::\n\n\n:::{.callout-note collapse=\"true\"}\n## Click to see the contents of the Slurm log file\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncat misc/slurm-fastqc-12521308.out    # You'll have a different number in the file name\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.bash-out}\nStarting FastQC script\nFri Aug 19 10:39:52 EDT 2022\nInput FASTQ file:   data/fastq/SRR7609467.fastq.gz\nOutput dir:         results/fastqc\n\nStarted analysis of SRR7609467.fastq.gz\nApprox 5% complete for SRR7609467.fastq.gz\nApprox 10% complete for SRR7609467.fastq.gz\nApprox 15% complete for SRR7609467.fastq.gz\nApprox 20% complete for SRR7609467.fastq.gz\nApprox 25% complete for SRR7609467.fastq.gz\nApprox 30% complete for SRR7609467.fastq.gz\nApprox 35% complete for SRR7609467.fastq.gz\nApprox 40% complete for SRR7609467.fastq.gz\nApprox 45% complete for SRR7609467.fastq.gz\nApprox 50% complete for SRR7609467.fastq.gz\nApprox 55% complete for SRR7609467.fastq.gz\nApprox 60% complete for SRR7609467.fastq.gz\nApprox 65% complete for SRR7609467.fastq.gz\nApprox 70% complete for SRR7609467.fastq.gz\nApprox 75% complete for SRR7609467.fastq.gz\nApprox 80% complete for SRR7609467.fastq.gz\nApprox 85% complete for SRR7609467.fastq.gz\nApprox 90% complete for SRR7609467.fastq.gz\nApprox 95% complete for SRR7609467.fastq.gz\nAnalysis complete for SRR7609467.fastq.gz\n\nListing output files:\ntotal 16K\n-rw-r--r-- 1 jelmer PAS0471 224K Aug 19 10:39 SRR7609467_fastqc.html\n-rw-r--r-- 1 jelmer PAS0471 233K Aug 19 10:39 SRR7609467_fastqc.zip\n\nDone with FastQC script\nFri Aug 19 10:39:58 EDT 2022\n```\n:::\n:::\n\n:::\n\nOur script already listed the output files,\nbut let's take a look at those too, and do so in the VS Code file browser in the\nside bar.\n**To actually view FastQC's HTML output file**,\nwe unfortunately need to download it with this older version of VS Code\nthat's installed at OSC &mdash;\nbut the ability to download files from here is a nice one!\n\n<p align=\"center\">\n<img src=img/vscode_download.png width=\"50%\">\n</p>\n\n<br>\n\n## Worked example, part II: A loop in a workflow script\n\n### A \"workflow\" file\n\nSo far, we've been typing our commands to run or submit scripts directly\nin the terminal.\n**But it's better to directly save these sorts of commands.**\n\nTherefore, we will now create a new file for the purpose of documenting the\nsteps that we are taking, and the scripts that we are submitting.\n**You can think of this file as your analysis lab notebook[^2].**\n\n[^2]: Though possibly a highly sanitized one -- you may want to store daily\n      notes and dead ends in a separate file.\n\nIt's easiest to also save this as a shell script (`.sh`) extension,\neven though it is not at all like the other scripts we've made,\nwhich are meant to be run/submitted in their entirety.\n\n:::{.callout-caution collapse=\"true\"}\n## Not like the other scripts\n\nOnce we've added multiple batch job steps,\nand the input of say step 2 depends on the output of step 1,\nwe won't be able to just _run_ the script as is.\nThis is because all the jobs would then be submitted at the same time,\nand step 2 would likely start running before step 1 is finished.\n\nThere are some possibilities with `sbatch` to make batch jobs wait on each\nother (e.g. the `--dependency` option), but this gets tricky quickly.\nAs also mentioned above, if you want a fully automatically rerunnable workflow /\npipeline, you should consider using a workflow management system\nlike [Snakemake](https://snakemake.readthedocs.io/en/stable/) or\n[NextFlow](https://www.nextflow.io/).\n:::\n\nSo let's go ahead and open a new text file, and save it as `workflow.sh`.\n\n<br>\n\n### Looping over all our files\n\nThe script that we wrote above will run FastQC for a single FASTQ file.\nNow, we will write a loop that iterates over all of our FASTQ files\n(only 8 in this case, but could be 100s just the same),\nand **submits a batch job for each of them.**\n\nLet's type the following into our `workflow.sh` script,\nand then copy-and-paste it into the terminal to run the loop:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nfor fastq_file in data/fastq/*fastq.gz; do\n    sbatch scripts/fastqc.sh \"$fastq_file\" results/fastqc\ndone\n```\n:::\n\n\n:::{.bash-out}\nSubmitted batch job 2451089  \nSubmitted batch job 2451090  \nSubmitted batch job 2451091  \nSubmitted batch job 2451092   \nSubmitted batch job 2451093  \nSubmitted batch job 2451094  \nSubmitted batch job 2451095  \nSubmitted batch job 2451096\n:::\n\n:::{.exercise}\n### On Your Own: Check if everything went well {-}\n\n- Use `squeue` to monitor your jobs.\n\n- Take a look at the Slurm log files while the jobs are running and/or after the\n  jobs are finished.\n  A nice trick when you have many log files to check,\n  is to use `tail` with a wildcard:\n  \n\n  ::: {.cell}\n  \n  ```{.bash .cell-code}\n  tail slurm-fastqc*\n  ```\n  :::\n\n- Take a look at the FastQC output files: are you seeing 12 HTML files?  \n\n:::\n\n<br>\n\n## Adapting our scripting workflow to run other command-line programs\n\n:::{.exercise}\n### On Your Own: Run another program {-}\n\nUsing the techniques you've learned in this workshop,\nand especially, using our FastQC script as a template,\ntry to run another command-line genomics program.\n\nWe below, we provide basically complete command-lines for three programs:\nMultiQC (summarizing FastQC output into one file), Trimmomatic\n(quality trimming and removing adapaters), and STAR (mapping files to a\nreference genome).\n\nYou can also try another program that you've been wanting to use.\n:::\n\n### {{< fa info-circle >}} Commands to load/install and run other software: {-}\n\n### MultiQC\n\nMultiQC is a very useful program that can summarize QC and logging output\nfrom many other programs,\nsuch as FastQC, trimming software and read mapping software.\n\nThat means if you have sequenced 50 samples with paired-end reads,\nyou don't need to wade through 100 FASTQ HTML files to see if each is of decent\nquality &mdash; MultiQC will summarize all that output in nice, interactive\nfigures in a single HTML file!\n\nHere, we'll assume you want to run it on the FastQC output,\nwhich simply means using your FastQC output directory as the input directory\nfor MultiQC.\n\n#### Install {-}\n\nMultiQC needs to be installed using an unusual 2-3 step procedure\n(one of the very few programs that can't be installed in one go with conda):\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nconda create -n multiqc python=3.7\nsource activate multiqc\nconda install -c bioconda -c conda-forge multiqc\n```\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n## Failed to install? Using other people's conda environments\n\nIf your MultiQC installation fails\n(this is a tricky one, with very many dependencies!),\nyou can also use mine, by putting these line in your script:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nmodule load miniconda3\nsource activate /fs/project/PAS0471/jelmer/conda/multiqc-1.12\n```\n:::\n\n:::\n\n#### Run {-}\n\nYou would run MultiQC **once for all files** (no loop!) and\n*with FastQC output as your input*, as follows:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# Copy the placeholder variables\ninput_dir=$1     # Directory where your FastQC output is stored\noutput_dir=$2    # Output dir of your choosing, e.g. result/multiqc\n\n# Activate the conda environment\nmodule load miniconda3\nsource activate multiqc\n\n# Run MultiQC\nmultiqc \"$input_dir\" -o \"$output_dir\"\n```\n:::\n\n\n<br>\n\n### Trimmomatic\n\nTrimmomatic is a commonly-used program to both quality-trim FASTQ data and\nto remove adapters from the sequences.\n\n#### Load the OSC module {-}\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nmodule load trimmomatic/0.38\n```\n:::\n\n\n#### Run {-}\n\nTo run Trimmomatic for one FASTQ file (=> loop needed like with FastQC):\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# Load the module\nmodule load trimmomatic/0.38\n\n# Copy the placeholder variables\ninput_fastq=$1    # One of our \"raw\" FASTQ files in data/fastq\noutput_fastq=$2   # Output file directory and name to your choosing\n\n# We provide you with a file that has all common Illumina adapters:\nadapter_file=/fs/ess/scratch/PAS2250/jelmer/mcic-scripts/trim/adapters.fa\n\n# Run Trimmomatic\n# (note that the OSC module makes the environment variable $TRIMMOMATIC available)\njava -jar \"$TRIMMOMATIC\" SE \\\n  \"$input_fastq\" \"$output_fastq\" \\\n  ILLUMINACLIP:\"$adapter_file\":2:30:10 \\\n  LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:36\n```\n:::\n\n\n:::{.callout-tip}\n## Avoid long lines with `\\`\nThe `\\` in the Trimmomatic command above simply allow us to continue a single\ncommand one a new line, so we don't get extremely long lines!\n:::\n\n<br>\n\n### STAR\n\n#### Load the OSC module\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nmodule load gnu/10.3.0\nmodule load star/2.7.9a\n```\n:::\n\n\n#### Index the genome\n\nFirst, we need to unzip the FASTA reference genome file:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngunzip reference/Pvul.fa.gz\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\n#SBATCH --cpus-per-task=8\n\n# Load the module\nmodule load gnu/10.3.0\nmodule load star/2.7.9a\n\n# Copy the placeholder variables\nreference_fasta=$1       # Pvul.fa reference genome FASTA file\nindex_dir=$2             # Output dir with the genome index\n\n# Run STAR to index the reference genome\nSTAR --runMode genomeGenerate \\\n     --genomeDir \"$index_dir\" \\\n     --genomeFastaFiles \"$reference_fasta\" \\\n     --runThreadN \"$SLURM_CPUS_PER_TASK\"\n```\n:::\n\n\n#### Map\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n#SBATCH --cpus-per-task=8\n\n# Load the module\nmodule load star/2.7.9a\n\n# Copy the placeholder variables\nfastq_file=$1         # A FASTQ file to map to the reference genome\nindex_dir=$2          # Dir with the genome index (created in indexing script)\n\n# Extract a sample ID from the filename!\nsample_id=$(basename \"$fastq_file\" .fastq.gz)\n\n# Run STAR to map the FASTQ file\nSTAR \\\n  --runThreadN \"$SLURM_CPUS_PER_TASK\" \\\n  --genomeDir \"$index_dir\" \\\n  --readFilesIn $fastq_file \\\n  --readFilesCommand zcat \\\n  --outFileNamePrefix \"$outdir\"/\"$sample_id\" \\\n  --outSAMtype BAM Unsorted SortedByCoordinate\n```\n:::\n\n\n<br><br>\n\n------\n\n------\n\n:::{.callout-tip}\n## Keyboard shortcut to run shell commands from the editor\n\nTo add a keyboard shortcut that will send code selected in the editor pane\nto the terminal\n(such that you don't have to copy and paste):\n\n- Click the &nbsp; {{< fa cog >}} &nbsp; (bottom-left) => `Keyboard Shortcuts`.\n\n- Find `Terminal: Run Selected Text in Active Terminal`, click on it,\n  then add a shortcut, e.g. <kbd>Ctrl</kbd>+<kbd>Enter</kbd>.\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}