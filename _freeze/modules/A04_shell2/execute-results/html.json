{
  "hash": "9e7507a7df6c65750b3b52f0244d1c6b",
  "result": {
    "markdown": "---\ntitle: \"The Unix Shell - Part II\"\nsubtitle: \"Working with files and directories\"\npagetitle: \"Unix shell part II\"\nhighlight-style: github\nnumber-sections: true\nengine: knitr\nauthor: Jelmer Poelstra\ndate: 2023-08-04\n---\n\n::: {.cell}\n\n:::\n\n\n-------\n\n<br>\n\n## Overview & getting set up {-}\n\nIn this session, we will continue learning about the Unix shell.\nSpecifically, we will focus on:\n\n- Commands for file and directory organization,\n  such as copying, moving, renaming, and deleting\n- Selecting multiple files with wildcards (\"globbing\")\n- Viewing text files\n- Redirecting the output of commands to files\n- Keyboard shortcuts, counting lines, and environment variables\n\nAs always, we'll be working in VS Code &mdash;\nif you don't already have a session open, see below how to do so.\n\n:::{.callout-tip collapse=\"true\"}\n## Starting VS Code at OSC - with a Terminal (Click to expand)\n1. Log in to OSC's OnDemand portal at <https://ondemand.osc.edu>.\n2. In the blue top bar, select `Interactive Apps`\n   and then near the bottom of the dropdown menu, click `Code Server`.\n3. In the form that appears on a new page:\n   - Select an appropriate OSC project (here: `PAS0471`)\n   - For this session, select `/fs/ess/PAS0471` as the starting directory\n   - Make sure that `Number of hours` is at least `2`\n   - Click `Launch`.\n4. On the next page, once the top bar of the box has turned green\n   and says `Runnning`, click `Connect to VS Code`.\n\n<figure><p align=\"center\"><img src=img/osc-code-launch_ed.png width=\"80%\"></p></figure>\n\n5. Open a Terminal by clicking\n   &nbsp; {{< fa bars >}} &nbsp; => `Terminal` => `New Terminal`.\n   (Or use one of the keyboard shortcuts:\n   <kbd>Ctrl</kbd>+<kbd>\\`</kbd> (backtick) or\n   <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>C</kbd>.)\n6. For now, your working directory doesn't matter &mdash; we'll change it in a bit.\n:::\n\n<br>\n\n## Some commands and features to get you up to speed\n\nWe'll start with a few miscellaneous shell commands and features that we'll\neither use again later on in today's session,\nor that are just good to know about sooner rather than later.\n\n### Counting lines with `wc -l`\n\nThe `wc` (short for `w`ord`c`ount) command can count things like the number of\ncharacters, words, and lines in a text file.\nGetting a **line count** for files is often especially useful,\ncertainly for genomic data files:\nfor example, the number of reads in a FASTQ file is simply the number\nof lines divided by 4, and other file types like GFF (an annotation format)\nhave one entry per line.\n\nTo get just the line count, we should use the **`-l` option** of `wc` &mdash;\nlet's count the number of lines in the metadata file in\n`/fs/ess/PAS0471/demo/202307_rnaseq/`:\n\n```bash\nwc -l /fs/ess/PAS0471/demo/202307_rnaseq/metadata/meta.tsv\n```\n```{.bash-out}\n9 /fs/ess/PAS0471/demo/202307_rnaseq/metadata/meta.tsv\n```\n\n<br>\n\n### Keyboard shortcuts\n\nUsing keyboard shortcuts can make your life in the Unix shell a lot easier.\nBelow, we'll see a couple particularly useful ones.\nFor more, see\n[the keyboard shortcuts reference page on this website](../info/shell_shortcuts.qmd).\n\n#### Command history & faster cursor movement {-}\n\nIt's common to re-execute command line expressions,\nand even more common to make slight changes to a previously executed one.\nTo cycle through your **command history** and retrieve previous commands[^1]\nyou can <kbd>&#8679;</kbd> and <kbd>&#8681;</kbd>.\n\n[^1]: From now on, I will refer to command-line expressions, with which I mean\n      everything you type in the shell until the next <kbd>Enter</kbd>\n      as simply a _command_.\n      \"Command\", then, can refer to either a command's name (e.g. `ls`) or\n      a full command line expression (e.g. `ls -lh path/to/dir`) &mdash;\n      this is potentially confusing but common usage and the context should\n      usually make the meaning clear.\n\nIf you hit the <kbd>&#8679;</kbd> (up arrow) once,\nyou'll get your most recent command,\nand if you keep hitting it, you'll go further back.\nThe<kbd>&#8681;</kbd> (down arrow) will go the other way: towards the present.\n\nFor example, say that we wanted to see what the output of the `wc` command is\nwhen we omit the `-l` option.\nAt the prompt, press <kbd>&#8679;</kbd> once to retrieve your previous `wc`\ncommand.\nThen, edit it to remove the `-l`, and press <kbd>Enter</kbd>:\n\n```bash\nwc /fs/ess/PAS0471/demo/202307_rnaseq/metadata/meta.tsv\n```\n```{.bash-out}\n9  27 236 /fs/ess/PAS0471/demo/202307_rnaseq/metadata/meta.tsv\n```\n\nA few other tips while you're trying this &mdash;\nperhaps practice this a few times:\n\n- To execute a command,\n  **you can press <kbd>Enter</kbd> regardless of where your cursor is**\n  on the line; it does _not_ need to be at the end of the line.\n\n- After pressing <kbd>&#8679;</kbd>, you needed to move to almost the beginning\n  of the line to make your edit (removing `-l`).\n  **There are two ways to speed up your cursor movements:**\n  \n  - If you keep <kbd>Ctrl</kbd> (Windows) or <kbd>Option</kbd> (Mac) pressed\n    while using the left (and right) arrows to move your cursor on the line,\n    you will move one \"word\", rather than one character, at a time!\n  \n  - If you press <kbd>Ctrl</kbd>+<kbd>A</kbd>, you will move all the way to\n    the beginning of the line\n    (and <kbd>Ctrl</kbd>+<kbd>E</kbd> will move you to the end of the line).\n\n::: {.exercise}\n#### Use `man wc` or `wc --help` to figure out what the three counts mean {-}\n<details><summary>Solution</summary>\nThe three numbers returned by `wc` when we don't give it any options are:\nthe number of lines, words, and bytes, respectively.\n\nSometimes you might want to get the number of characters, which you can do\nwith `wc -c`.\n</details>\n:::\n\n#### Cancel and kill {-}\n\nIt is also common to want to **cancel a running command or get out of a \"hanging\" prompt**,\nand you can do so with **<kbd>Ctrl</kbd>+<kbd>C</kbd>**.\n\nIf you accidentally omit a file name with a command like `wc`\nthat _requires_ an argument[^2], something odd happens &mdash;\nyou move to a new line in the terminal but don't get your regular prompt\nback; it appears to \"hang\". Try it:\n\n[^2]: Though we will see later that you can also \"pipe in\" input to `wc` and\n      many other commands, in which case it does not need a file name as an\n      argument, since you are providing data for it to operate on in a different\n      way.\n\n```bash\nwc\n\n```\n\nTo get out of this, press <kbd>Ctrl</kbd>+<kbd>C</kbd> to cancel the partial\ncommand, and get your prompt back.\nThere are several other ways you might accidentally try to execute incomplete commands,\nsuch as **forgetting to close parentheses or quotes**, and in some cases,\nyou don't even know what the problem is.\nJust press <kbd>Ctrl</kbd>+<kbd>C</kbd> and then take a close look at your\ncommand to find the problem.\n\nAnother type of situation where <kbd>Ctrl</kbd>+<kbd>C</kbd> is useful is\nwhen you execute a command that does actually run,\nbut you realize, for example, that there is a mistake in the command (wrong input file!),\nor that the command will take way too long to run interactively.\n<kbd>Ctrl</kbd>+<kbd>C</kbd> will then **\"kill\" (cancel) the running process**.\nA somewhat silly example is the sleep command,\nwhich you can use to make the computer wait between successive commands:\n\n```bash\n# This will \"run\" for 60 seconds, after which you get your prompt back \nsleep 60s\n# Press Ctrl + C to get your prompt back sooner!\n```\n```{.bash-out}\n^C\n```\n\n<br>\n\n### Environment variables and the `echo` command\n\nIn computer languages, \"**variables**\" store information.\nWhen we reference a _shell variable_ to retrieve its value,\nwe have to put a **`$`** in front of its name\n(unlike in say R or Python) &mdash;\nfor instance, we reference a variable with the name `x` as `$x`[^3].\n\n[^3]: The advantage of this is that it makes it very easy to recognize variables\n      inside scripts and so on!\n\nIn later sessions, we'll see how we can create our own variables,\nand we will be using these a lot!\nBut the Unix shell also has a number of _pre-existing variables_,\nwhich are called **environment variables** and have ALL-CAPS names.\nFor example, the variable **`$HOME`** contains the path to your Home directory,\nand the variable **`$USER`** contains your username.\n\nHow can we examine the value of variables?\nJust typing, e.g., `$USER` at the prompt will not work:\nas pointed out in the previous session,\n_every command line expression should start with a command_,\nand a variable is not a command.\nInstead, we should use the **`echo` command**,\nwhich simply prints whatever text you give it:\n\n```bash\n# You don't have to use quotes (\" \"), at least here, but it's good practice\necho \"Hello there\"    \n```\n``` {.bash-out}\nHello there\n```\n\nWe'll also be using the `echo` command a lot,\nsuch as by letting our shell scripts report progress and the values of variables.\nIf we use echo with a(n environment) variable like `$USER`,\nthe variable's _value_ will be printed:\n\n```bash\n# The shell will replace $USER by its value, so echo will just see 'jelmer'\necho \"$USER\"\n```\n```{.bash-out}\njelmer\n```\n\n:::{.exercise}\n#### Your Turn: `echo` and environment variables {-}\n\n- Print \"Hello there \\<user\\>\" to the screen  \n  (i.e., `<user>` should be replaced by your actual username).\n\n- Use an _environment variable_ mentioned above to move to your Home directory,\n  and then move back to where you were (as seen last time).\n\n<details><summary>Hints for the second question (click here)</summary>\nRecall from the previous session that:\n\n- The command `cd` will change your working directory\n- `cd -` will move back to your previous directory\n\n</details>\n\n<details><summary>Solutions (click here)</summary>\n\n- **Print \"Hello there \\<user\\>\" to the screen:**\n\n```bash\n# (This would also work without the \" \" quotes)\necho \"Hello there $USER\"\n```\n```{.bash-out}\nHello there jelmer\n```\n\n<br>\n\n- **Use an environment variable to move to your Home directory,**\n  **check that it worked, then move back to where you were:**\n\n```bash\n# Move to your Home directory\ncd $HOME\n\n# Print the working directory\npwd\n#> /users/PAS0471/jelmer\n\n# Move back to your previous working directory\ncd -\n```\n</details>\n:::\n\n<br>\n\n## Commands for file organization\n\nBelow, we'll learn about the key commands for directory and file organization:\n`mkdir` (create dirs), `cp` (copy), `mv` (move and rename), and `rm` (remove).\nBut first off, why do we need to learn this when VS Code and the OnDemand\nwebsite itself have file browsers with this kind of functionality?\n\n- We'll regularly want to use these commands non-interactively in our shell scripts\n- These commands are often a more efficient way to organize files\n- They provide a good way to get more familiar with the Unix shell and how\n  Unix commands work\n- It's good to know these basics and be prepared for situations where you do not\n  have access to OnDemand/VS Code.\n\n### Create dirs with `mkdir` (and files with `touch`)\n\nThe `mkdir` command creates new directories:\nyou can give it one or more arguments to create one or more directories.\nCreate one for yourself, with your username, in `/fs/ess/PAS0471`:\n\n```bash\nmkdir /fs/ess/PAS0471/$USER\n```\n\nNow, move to that directory:\n\n```bash\ncd /fs/ess/PAS0471/$USER\n```\n\nNext, we'll create a directory for these introductory sessions and go there:\n\n```bash\nmkdir rnaseq_intro\ncd rnaseq_intro       # Use Tab completion\n```\n\nLet's switch VS Code to this directory:\nclick &nbsp; {{< fa bars >}} &nbsp; => &nbsp; `File` &nbsp; => &nbsp; `Open Folder`,\nand select `/fs/ess/PAS0471/<user>/rnaseq_intro`.\nYou'll have to open a Terminal window again, too.\n\n::: {.callout-tip}\n`/fs/ess/PAS0471/<user>/rnaseq_intro` (with `<user>` replaced by your username)\nis going to be **your working dir for upcoming sessions too**,\nso you should always open/reload VS Code in that dir.\n:::\n\nFinally, let's make several dirs at once &mdash;\nthis is how I usually structure my research project directories:\n\n```bash\nmkdir data metadata results scripts sandbox\n```\n\n#### Recursive `mkdir` {-}\n\nBy default, `mkdir` does not work recursively:\nit will refuse to make a dir inside a dir that does not (yet) exist.\nAnd if you try to do so, the resulting error might confuse you:\n\n```bash\nmkdir sandbox/2023/08\n```\n```{.bash-out}\nmkdir: cannot create directory ‘sandbox/2023/08’: No such file or directory\n```\n> _Why won't you do your job, `mkdir`!?_\n\nInstead, we need to use the `-p` option to `mkdir`:\n\n```bash\nmkdir -p sandbox/2023/08\n```\n\nIn general,\nUnix commands are designed to be powerful and to do exactly what you asked,\nbut **non-recursive default behaviors**\n(we will see this with the commands to copy (`cp`) and delete (`rm`) files as well)\nare an exception to this.\nWe can assume that the developers thought that recursive default behaviors\nwere just too risky.\n\n::: {.callout-note collapse=\"true\"}\n#### When a dir already exists, `-p` will also suppress any errors (Click to expand)\nThe `-p` also changes `mkdir`'s behavior when you try to create a dir that\nalready exists.\n\nBy default, it will give an error:\n\n```bash\n# Note: we (should have) just created this dir above, so it already exists\nmkdir sandbox/2023/08\n```\n```{.bash-out}\nmkdir: cannot create directory ‘sandbox/2023/08’: File exists\n```\n\nWith `-p`, it doesn't complain (but won't do anything, like overwriting, either):\n\n```bash\nmkdir -p sandbox/2023/08    # Should not give any output\n```\n\nAs we'll see later,\nall of this makes `mkdir -p` ideal for non-interactive usage in shell scripts.\n:::\n\n#### Create new _files_ with `touch` {-}\n\nAs we have learned the command to make new dirs,\nyou may be wondering what the equivalent command is to make new, empty files:\nit is **`touch`**.\n\n```bash\n# Create three new, empty files:\ntouch file1 file2 file3\n```\n\nThis command isn't as commonly used as `mkdir` because we usually create new files\non the fly with command _output redirection_, which we'll learn about below.\nBut it's certainly useful to create dummy files to practice your shell skills.[^4]\n\n[^4]: When you use `touch` on _existing_ files, all it will do is change the\n      timestamp that the file was most recently modified:\n      hence the name of this command.\n\n<br>\n\n### Copy files and dirs with `cp`\n\nAbove, you created your own directory &mdash;\nnow, let's get you a copy of the partial RNAseq dataset in\n`/fs/ess/PAS0471/demo/202307_rnaseq/`\nthat we'll be working with throughout these sessions.\n\nThe `cp` command copies files and/or directories from one location to another.\nIt has **two required arguments**:\nwhat you want to copy (the _source_), and where you want to copy it to\n(the _destination_).\nSo, we can summarize its basic syntax as **`cp <source> <destination>`**.\n\nWe'll start by copying a file with some metadata on the RNAseq samples:\n\n```bash\ncp -v /fs/ess/PAS0471/demo/202307_rnaseq/metadata/meta.tsv metadata/\n```\n```{.bash-out}\n‘/fs/ess/PAS0471/demo/202307_rnaseq/metadata/meta.tsv’ -> ‘metadata/meta.tsv’\n```\n\nThis told `cp` to copy the metadata file into the `metadata` dir you created earlier.\n\n::: {.callout-note}\n#### `-v` option for verbose\nWe used the **`-v` option**, short for  **v**erbose,\nto make `cp` tell us what it did:\n\n- Recall that by default,\n  Unix commands are generally silent when performing actions like this.\n- But many commands have a verbose option (nearly always `-v`) to make them\n  tell us what they did, which can be very useful.\n:::\n\nLike `mkdir`, **`cp` is not recursive by default**.\nIf you want to copy a directory and all of its contents,\nwe need to use its `-r` option[^5].\nWe'll use that option to copy the dir with FASTQ files:\n\n[^5]: `-r` is a common option name for recursive behaviour among Unix commands\n      (`mkdir` is an exception with its `-p`).\n\n```bash\ncp -rv /fs/ess/PAS0471/demo/202307_rnaseq/data/fastq data/\n```\n```{.bash-out}\n‘/fs/ess/PAS0471/demo/202307_rnaseq/data/fastq’ -> ‘data/fastq’\n‘/fs/ess/PAS0471/demo/202307_rnaseq/data/fastq/Miapaca2_A178V_R1.fastq.gz’ -> ‘data/fastq/Miapaca2_A178V_R1.fastq.gz’\n‘/fs/ess/PAS0471/demo/202307_rnaseq/data/fastq/ASPC1_G31V_R2.fastq.gz’ -> ‘data/fastq/ASPC1_G31V_R2.fastq.gz’\n‘/fs/ess/PAS0471/demo/202307_rnaseq/data/fastq/ASPC1_A178V_R2.fastq.gz’ -> ‘data/fastq/ASPC1_A178V_R2.fastq.gz’\n‘/fs/ess/PAS0471/demo/202307_rnaseq/data/fastq/ASPC1_G31V_R1.fastq.gz’ -> ‘data/fastq/ASPC1_G31V_R1.fastq.gz’\n‘/fs/ess/PAS0471/demo/202307_rnaseq/data/fastq/ASPC1_A178V_R1.fastq.gz’ -> ‘data/fastq/ASPC1_A178V_R1.fastq.gz’\n‘/fs/ess/PAS0471/demo/202307_rnaseq/data/fastq/Miapaca2_A178V_R2.fastq.gz’ -> ‘data/fastq/Miapaca2_A178V_R2.fastq.gz’\n‘/fs/ess/PAS0471/demo/202307_rnaseq/data/fastq/Miapaca2_G31V_R1.fastq.gz’ -> ‘data/fastq/Miapaca2_G31V_R1.fastq.gz’\n‘/fs/ess/PAS0471/demo/202307_rnaseq/data/fastq/Miapaca2_G31V_R2.fastq.gz’ -> ‘data/fastq/Miapaca2_G31V_R2.fastq.gz’\n```\n\nLet's get an overview of the files we now have in our `rnaseq_intro` dir:\n\n```bash\ntree -C                 # Your own output should have colors\n```\n```{.bash-out}\n.\n├── data\n│   └── fastq\n│       ├── ASPC1_A178V_R1.fastq.gz\n│       ├── ASPC1_A178V_R2.fastq.gz\n│       ├── ASPC1_G31V_R1.fastq.gz\n│       ├── ASPC1_G31V_R2.fastq.gz\n│       ├── Miapaca2_A178V_R1.fastq.gz\n│       ├── Miapaca2_A178V_R2.fastq.gz\n│       ├── Miapaca2_G31V_R1.fastq.gz\n│       └── Miapaca2_G31V_R2.fastq.gz\n├── metadata\n│   └── meta.tsv\n├── results\n├── sandbox\n│   └── 2023\n│       └── 08\n└── scripts\n\n8 directories, 9 files\n```\n\n<br>\n\n### Moving with `mv`, and general `cp`/`mv` tips\n\nThe `mv` command is nearly identical to the `cp` command, except that it:\n\n- **Moves** rather than copies files and/or dirs\n- Works **recursively** by default\n\nWe'll use this section to learn a few more things about\n_the usage of both these commands_.\n\n- **By default, both `mv` and `cp` will overwrite files without warning!**\n  Use the `-i` (for `i`nteractive) option to make it let you confirm before\n  overwriting anything\n  (that option also exists for `rm`, where you'll practice with it).\n\n- There is **no separate command for renaming**,\n  because both `cp` and `mv` allow you to provide a different name for the target.\n  Thus, if used as follows, `mv` functions merely as a renamer:\n\n  ```bash\n  mv meta.tsv meta_version2.tsv\n  ```\n\n  And we can move and rename at the same time as well &mdash;\n  let's do that to restore our original location and name for the metadata file:\n\n  ```bash\n  mv meta_version2.tsv metadata/meta.tsv\n  ```\n\n- **Use the `.` notation** for the current working dir if you want to copy/move\n  something there:\n\n  ```bash\n  cp -v /fs/ess/PAS0471/demo/202307_rnaseq/README.md .\n  ```\n  ```{.bash-out}\n  ‘/fs/ess/PAS0471/demo/202307_rnaseq/README.md’ -> ‘README.md’\n  ```\n\n:::{.callout-note}\n#### Renaming rules for both `cp` and `mv`\nIf the destination is:\n\n- **An existing dir**, the file(s) will keep their original names.\n  \n- **Not an existing dir**, the path specifies the new name of the file or dir,\n  depending on what the source is.\n\n  However, neither command will create \"additional, intermediate\" directories,\n  so `mv metadata/meta.tsv metadata/misc/meta.tsv` would not work if `metadata/misc`\n  doesn't already exist.\n:::\n\n:::{.exercise}\n#### Your Turn: Practice with `mv` {-}\n\nIn which directory (in terms of a relative path from your working dir)\nwould the FASTQ files end up with each of the following commands?\n\n- `mv data/fastq data/fastq_files`\n- `mv data/fastq fastq`\n- `mv data/fastq .`\n\nWhat if you wanted to move the FASTQ files _directly_ into your current\nworking directory (from `data/fastq`)?  \n_(You should know how to do this 1-by-1 but we have not yet seen the special_\n_character you can use to do this for all files at once &mdash; see the hint.)_\n\n<details><summary>Hint for the last question (click here)</summary>\nYou can use the asterisk (star) symbol `*` to select all files in a directory.\n\n(We'll learn more about `*` later.\nIn short, it is one of a few _shell wildcards_ used to expand to filenames,\nand this one specifically matches any number of any character,\nand as such will match all possible filenames when used by itself.)\n</details>\n\n<details><summary>Solutions (click here)</summary>\n\n_In which directory (in terms of relative path from your working dir)_\n_will the FASTQ files end up with each of the following commands?_\n\n- `mv data/fastq data/fastq_files` &mdash; **in the dir `fastq_files`**\n  (we've really just renamed the dir `fastq` to `fastq_files`)\n\n- `mv data/fastq fastq` &mdash; **in `fastq`**\n  (because our source is a dir, so is the destination)\n\n- `mv data/fastq .` &mdash; **in `fastq` also!**\n  (we'd need the syntax shown below to move the individual files directly\n  into our current dir)\n\n_What if you wanted to move the FASTQ files directly into your current_\n_working directory?_\n\nFor one file:\n\n```bash\nmv data/fastq/ASPC1_A178V_R1.fastq.gz .\n```\n\nFor all files:\n\n```bash\nmv data/fastq/* .\n```\n\n</details>\n\n:::\n\n<br>\n\n### Intermezzo: the trouble with spaces in file names\n\nIn the Unix shell, **spaces are essentially special characters**\nthat are used to _separate_ commands, options, and arguments &mdash;\nwith the latter often being one or more file names.\n\nFor example, one of our earlier `mkdir` commands,\n`mkdir data metadata results scripts sandbox`,\ncreated five separate dirs instead of one dir with four spaces in it.\n\nTherefore, to create or refer to a _file or directory name with a space in it_,\nyou need some special notation.\nTwo different methods are available:\n**quoting** the entire file name,\nand \"**escaping**\" the special meaning of the space:\n\n```bash\n# Method 1: Put quotes around the entire file name:\nmkdir \"my new dir\"\n\n# Method 2: Escape the special meaning of spaces by preceding them with a backslash\nmkdir my\\ new\\ dir2\n```\n\nLet's see what we have now:\n\n```bash\nls -1    # The \"-1\" (dash one) option to ls lists each entry on its own line\n```\n```{.bash-out}\ndata\nmetadata\nmy new dir\nmy new dir2\n```\n\nIn any situation where we refer to file or dir names that contain spaces,\nwe'll need quotes or escaping &mdash; consider this failing command:\n\n```bash\ncd my new dir\n```\n```{.bash-out}\nbash: cd: my: No such file or directory\n```\n\nSimilarly, `ls` will fail as follows:\n\n```bash\nls my new dir\n```\n```{.bash-out}\nls: cannot access my: No such file or directory\nls: cannot access new: No such file or directory\nls: cannot access dir: No such file or directory\n```\n\n:::{.exercise}\n#### Why does `cd` produce one error while `ls` produces three?  {-}\n\n<details><summary>Solution (click here)</summary>\n\n`cd` tried to move to non-existing dir `my`,\nand _ignored_ the arguments `new` and `dir`, since it only accepts one argument.\n\n`ls` accepts multiple arguments and will try to list all 3 listed items,\nnone of which happens to exist. \n\n</details>\n\n:::\n\nFortunately, tab completion will insert backspaces for you &mdash;\ntype `cd my` and press <kbd>Tab</kbd>:\n\n```sh\n# After typing cd and pressing tab, the line should complete as follows:\ncd my\\ new\\ dir\n\n# Let's move back up:\ncd ..\n```\n\nNevertheless, the moral of the story is that you should always\n**avoid spaces in file names** when working at OSC.\nIn fact, you should do so in any project that uses the Unix shell or any coding.\nIf you need to separate words, then use underscores (`_`), dashes (`-`),\nand/or capitalization.\nFor example:\n\n```bash\nmkdir my_new_dir     # \"snake\" case\nmkdir my-new-dir     # \"kebab\" case\nmkdir myNewDir       # \"camel\" case\n```\n\n::: {.callout-note}\n#### More file and dir naming tips\nIt's also a good idea to avoid characters other than letters, numbers,\nand underscores (`_`), dashes (`-`), and periods (`.`) in dir and file names.\n\nIdeally, you'd only use the `.` to separate the _extension_\n(i.e., the abbreviation that indicates the type of file, like `txt` or `tsv`)\nfrom the rest of the file name,\nbut it is (unfortunately) also common to use `.` as a \"word separator\" &mdash;\ne.g. `my_file.filtered.sorted.txt`.\n\nFinally, avoid using _a number as the first character_ in a file or dir name.\n:::\n\n<br>\n\n### Removing files with `rm`\n\nOur final command in this series is `rm`,\nwhich removes (deletes) files and directories.\n\nOne important thing to note upfront is that `rm` will\n**permanently and irreversibly delete files**\nwithout the typical \"intermediate step\" of placing them in a trash bin,\nlike you are used to with your personal computer.\nWith a healthy dosis of fear installed, let's dive in.\n\nTo remove one or more files, you can simply pass the file names as arguments to `rm`\nas with previous commands.\nWe will also use the `-v` (`v`erbose) option to have it tell us what it did:\n\n```bash\n# This assumes you ran `touch file1 file2 file3` earlier on; do so now if needed\nrm -v file1            # Remove 1 file\n```\n```{.bash-out}\nremoved ‘file1’\n```\n```bash\nrm -v file2 file3      # Remove 2 files\n```\n```{.bash-out}\nremoved ‘file2’\nremoved ‘file3’\n```\n\n_(If it seems cumbersome to type a bunch of file names,_\n_we'll see below how you can use a Shell wildcard to select many files at once.)_\n\n#### Recursive `rm` {-}\n\nAs a safety measure, `rm` will by default only delete files and not directories\nor their contents &mdash; i.e., like `mkdir` and `cp`, it refuses to act\n_recursively_ by default.\n**To remove dirs and their contents, use the `-r` option:**\n\n```bash\n# You should have these from 2.4 (if not, run: mkdir \"my new dir\" \"my new dir2\")\nrm -r \"my new dir\" \"my new dir2\"\n```\n```{.bash-out}\nremoved directory: ‘my new dir’\nremoved directory: ‘my new dir2’\n```\n\nYou should obviously be quite careful with `rm -r`!\nIf you'd run it on say your personal dir within PAS0471,\n`/fs/ess/PAS0471/<user>`, after working in there for months on different projects,\nit would remove all of those files in one fell swoop!\n(Though luckily, OSC does keep backups in the project dirs.)\n\n#### Preventing disaster {-}\n\n**To make it less likely for bad things to happen**,\nhere are some measures you can take as well as a built-in feature worth pointing\nout:\n\n- If you're worried about a specific removal you are about to perform,\n  you could use **`rm -i`** (short for `i`nteractive) to have remove ask you to confirm\n  the removal of every dir and file,\n  though this is not practical for dirs with _lots_ of files:\n\n```bash\n# Make some files for this exercise\nmkdir sandbox/remove_test\ntouch sandbox/remove_test/a1 sandbox/remove_test/a2 sandbox/remove_test/a3\n\n# Now remove them interactively, press 'y' (or 'n') for every question\nrm -ri sandbox/remove_test\n```\n```{.bash-out}\nrm: descend into directory sandbox/remove_test? y\nrm: remove regular empty file sandbox/remove_test/a1’? y\nrm: remove regular empty file sandbox/remove_test/a2’? y\nrm: remove regular empty file sandbox/remove_test/a3’? y\n```\n\n- You can **write-protect important files**, as we'll see in the next session.\n\n- You can use **`rmdir`** whenever a dir you want to remove _should_ be empty.\n  That command will only remove empty dirs, and fails on non-empty dirs!\n\n- Finally, it may be assuring to learn that\n  **you will not be able to remove other people's files at OSC**\n  (since you do not have \"write permission\" for them)[^6].\n  For example, the file below was created by me and you won't be able to remove\n  (or edit) it:\n\n[^6]: At least not by default, the person who created the file can change this.\n\n```bash\nrm /fs/ess/PAS0471/demo/202307_rnaseq/README.md\n```\n```{.bash-out}\nrm: cannot remove ‘/fs/ess/PAS0471/demo/202307_rnaseq/README.md’: Permission denied\n```\n\n<br>\n\n## Globbing with shell wildcard expansion\n\n_Shell wildcard expansion_ is a very useful technique to **select files**.\nSelecting files with wildcard expansion is called _globbing_.\n\n### Shell wildcards\n\nIn the term \"wildcard expansion\",\n_wildcard_ refers to a few symbols that have a special meaning:\nspecifically, they match certain characters in file names.\n(We'll see below what _expansion_ refers to.)\n\nHere, we'll only talk about the most-used wildcard, `*`, in detail.\nBut for the sake of completeness, I list them all below:\n\n| Wildcard                  | Matches                                                      |\n|---------------------------|--------------------------------------------------------------|\n| **`*`**                   | Any number of any character, including nothing               |\n| **`?`**                   | Any single character                                         |\n| **`[]`** and **`[^]`**    | One or none (`^`) of the \"character set\" within the brackets |\n\n<br>\n\n### Using the `*` wildcard\n\nHere are some file matching examples with `*` &mdash;\nif we are in our directory `data/fastq`, then:\n\n| Pattern        | Matches files whose names...  | Matches in our dir            |\n|----------------|-------------------------------|-------------------------------|\n| `*fastq.gz`    | **End in** \".fastq.gz\"        | All files (but this patterns is useful to select files by extension) |\n| `A*`           | **Start with** a capital \"A\"  | Files for the ASPC1 samples   |\n| `*_R1*`        | **Contain** \"_R1\"             | Files with forward reads      |\n| `*`            | Anything[^7]                  | All files\n\nIn the above, note that:\n\n- Because `*` matches \"zero characters\" as well,\n  `A*` also matches a file whose name is just `A`,\n  `*fastq.gz` also matches just `fastq.gz`, and `*_R1*` also matches just `_R1`.\n\n- As a whole, the expressions with a wildcard need to match the _entire_ filename,\n  which is why, for example, you need `*`s on _both sides_ of `_R1` in the last\n  example to match any file that _contains_ this string.\n\n[^7]: However, it will not match so-called \"hidden files\" whose names start with a `.`.\n\nIt's also useful to realize that _wildcard expansion_\n(e.g., the expansion of `*fastq.gz` to all FASTQ files in the working dir)\n**is done by the shell itself, and not by any specific command.**\nAs a consequence,\nwe can use shell wildcards with any command that takes file names as arguments\n&mdash; for example:\n\n```bash\necho data/fastq/A*R1.fastq.gz\n```\n```{.bash-out}\ndata/fastq/ASPC1_A178V_R1.fastq.gz  data/fastq/ASPC1_G31V_R1.fastq.gz\n```\n\n```bash\nls data/fastq/A*R1.fastq.gz\n```\n```{.bash-out}\ndata/fastq/ASPC1_A178V_R1.fastq.gz  data/fastq/ASPC1_G31V_R1.fastq.gz\n```\n\n```bash\n# Note that these are line-counts of the compressed file, not reflecting the # of reads\nwc -l data/fastq/A*R1.fastq.gz\n```\n```{.bash-out}\nwc -l data/fastq/A*R1.fastq.gz\n  15358 data/fastq/ASPC1_A178V_R1.fastq.gz\n  14974 data/fastq/ASPC1_G31V_R1.fastq.gz\n  30332 total\n```\n\n:::{.exercise}\n#### Your Turn: practice with `*` {-}\n\nWhat pattern would you use if you wanted to select:\n\n- FASTQ files for all `A178V` samples in our dir `data/fastq`\n\n- In a fictional example (we don't have plain FASTQ files),\n  all gzipped (`.fastq.gz`) and plain FASTQ files (`.fastq`) at the same time?\n\n<details><summary>Solutions (click here)</summary>\n\n- `data/fastq/*A178V*`\n  _(We'll need a `*` on either side of our pattern, because the file names_\n  _neither start not end with the pattern.)_\n\n- `data/fastq/*.fastq*`\n  _(Recall that the `*` will also match nothing, so this will also match files_\n  _whose name _end_ in `.fastq`, i.e. plain FASTQ files)_\n\n</details>\n:::\n\n:::{.callout-warning collapse=\"true\"}\n## Don't confuse shell wildcards with _regular expressions_! (Click to expand)\n\nFor those of you who know some _**regular expressions**_ from coding in e.g. R,\nPython, or from advanced usage of GUI-based text editors like jEdit:\nwildcards are _conceptually_ similar to these,\nbut the `*` and `?` symbols don't have the same meaning,\nand there are way fewer shell wildcards than regular expression symbols.\n\nIn particular, note that `.` is not a shell wildcard and thus represents\na literal period when globbing.\n\nWe _can_ also use regular expressions in the Shell,\nbut this is functionality included in several specific commands,\nlike `grep` and `sed`,\nand is not a form of shell expansion. \n:::\n\n<br>\n\n### Everyday usage of globbing\n\nIt is very common to use globbing to move (`mv`), copy (`cp`),\nor remove (`rm`) multiple files at once.\n\nBecause a `*` by itself matches all files,\nit can for example be useful if you want to copy the entire _contents_ of a\ndirectory into your working dir (recall the exercise in 2.3):\n\n```bash\n# You can run this if you want, but then remove the copied FASTQ files afterwards\ncp data/fastq/* .\n```\n\nA few more globbing examples:\n\n```bash\ncp -v data/fastq/*Miapaca*_R1* .     # Copy 3 FASTQ files to your working dir \n```\n```{.bash-out}\n‘data/fastq/Miapaca2_A178V_R1.fastq.gz’ -> ‘./Miapaca2_A178V_R1.fastq.gz’\n‘data/fastq/Miapaca2_G31V_R1.fastq.gz’ -> ‘./Miapaca2_G31V_R1.fastq.gz’\n```\n\n```bash\nrm -v *fastq.gz                  # Remove all FASTQ files in your working dir\n```\n```{.bash-out}\nremoved ‘Miapaca2_A178V_R1.fastq.gz’\nremoved ‘Miapaca2_G31V_R1.fastq.gz’\n```\n\nIn next sessions, we'll also use globbing a lot to _select files to loop over_.\n\n:::{.callout-note collapse=\"true\"}\n#### Recursive globbing (Click to expand)\n\nGlobbing does not work recursively by default, so `ls *fastq.gz` would only\nreturn gzipped FASTQ files in your current working dir.\n\nAfter running some bionformatics program, it's relatively common to have FASTQ\nfiles in a separate directory for each sample.\nIn cases like that, you can use `**` to match any directory.\nFor example, in the pattern below,\nthe `**` would \"traverse\" the `fastq` dir within the `data` dir:\n\n```bash\nls data/**/*fastq.gz\n```\n```{.bash-out}\ndata/fastq/ASPC1_A178V_R1.fastq.gz  data/fastq/ASPC1_G31V_R1.fastq.gz  data/fastq/Miapaca2_A178V_R1.fastq.gz  data/fastq/Miapaca2_G31V_R1.fastq.gz\ndata/fastq/ASPC1_A178V_R2.fastq.gz  data/fastq/ASPC1_G31V_R2.fastq.gz  data/fastq/Miapaca2_A178V_R2.fastq.gz  data/fastq/Miapaca2_G31V_R2.fastq.gz\n```\n\nBut `**` itself is not recursive either by default and only \"traverses a single level\",\nso you'd need the following to list any FASTQ files that are exactly two\nlevels deep from your current working dir:\n\n```bash\nls **/**/*fastq.gz\n```\n```{.bash-out}\ndata/fastq/ASPC1_A178V_R1.fastq.gz  data/fastq/ASPC1_G31V_R1.fastq.gz  data/fastq/Miapaca2_A178V_R1.fastq.gz  data/fastq/Miapaca2_G31V_R1.fastq.gz\ndata/fastq/ASPC1_A178V_R2.fastq.gz  data/fastq/ASPC1_G31V_R2.fastq.gz  data/fastq/Miapaca2_A178V_R2.fastq.gz  data/fastq/Miapaca2_G31V_R2.fastq.gz\n```\n\nWhile this would not find them:\n\n```bash\nls **/*fastq.gz\n```\n```{.bash-out}\nls: cannot access **/*fastq.gz: No such file or directory\n```\n\nHowever, you can make `**` recursive by turning on the `globstar` option:\n\n```bash\nshopt -s globstar     # Turn on 'globstar'\n\nls **/*fastq.gz\n```\n```{.bash-out}\ndata/fastq/ASPC1_A178V_R1.fastq.gz  data/fastq/ASPC1_G31V_R1.fastq.gz  data/fastq/Miapaca2_A178V_R1.fastq.gz  data/fastq/Miapaca2_G31V_R1.fastq.gz\ndata/fastq/ASPC1_A178V_R2.fastq.gz  data/fastq/ASPC1_G31V_R2.fastq.gz  data/fastq/Miapaca2_A178V_R2.fastq.gz  data/fastq/Miapaca2_G31V_R2.fastq.gz\n```\n\nWith `globstar` turned on,\nthe pattern above would find gzipped FASTQ files no matter how many dir levels\ndeep they are (including when they are in your current working dir).\n:::\n\n<br>\n\n## Viewing text files\n\nHere, I'll give a quick overview of the most common commands to view text\nfiles in the shell.\n\nSeveral of these commands are especially useful to look at (very) large files,\nsuch as genomic data files, and we'll talk more about them in the next session.\n\n::: {.callout-note}\n#### Viewing files in VS Code\nFor smaller text files,\nyou might also choose to **open them in the editor pane in VS Code**.\nYou can do so by finding and clicking on them in the Explorer in the side bar.\nAdditionally, when you list files _in the shell_ in VS Code,\nyou can hold <kbd>Ctrl</kbd> (Windows) or <kbd>Command</kbd> (Mac) and then\nclick on a file name (you should see it being underlined before you click)!\n\nUnlike the shell,\nVS Code is also able to open image files (e.g. `.png`, `.jpg`) and PDFs this\nway &mdash; and as we'll see later,\nyou can even render HTML files in the editor pane.\n\nVS Code also handles the viewing of large text files better than most visual\ntext editors, but I would still recommend to mostly view genomic-scale data\nfiles in the shell instead. \n:::\n\n### `cat`\n\nThe `cat` (short for con`cat`enate) command will print the full contents of a file.\nIt is therefore mostly conventient for smaller files,\nsince the contents of very large files will just stream by on your screen.\n\nFor example, let's take a look at the `README.md` file in your working dir:\n\n```bash\n# If you don't have this file, first run:\n# cp -v /fs/ess/PAS0471/demo/202307_rnaseq/README.md .\ncat README.md\n```\n```{.bash-out}\n# README for /fs/ess/PAS0471/demo/202307_rnaseq\n\nThis directory contains files from an RNAseq project by the Montserrate-Cruz lab,\nmeant to demonstrate Unix shell basics.\n\nIn the `data/fastq` directory, there are 8 gzipped FASTQ files for 4 samples\n(the sequencing was done in a paired-end fashion and each sample has a file with\nforward reads (`_R1.fastq.gz`) and a file with reverse reads (`_R2.fastq.gz`)).\n\nTo be able to demonstrate Unix shell and bioinformatics basics,\nthose 8 files do not represent the full dataset for the experiment in question.\nFiles are present for only 4 of the 18 samples,\nand the individual files are much smaller than the originals:\n100,000 reads were randomly sub-sampled\n(the original files contained ~30 million reads each).\n\nA very simple metadata TSV (tab-separated values) text file is present in\n`metadata/meta.tsv`, with one row per input file,\nand columns specifying the read direction, sample ID, cell line, and variant.\n```\n\n::: {.callout-note collapse=\"true\"}\n#### `.md` = Markdown (Click to expand)\n\n`.md` is the extension for \"Markdown\" files.\nMarkdown is a very simple but still quite powerful text \"Markup language\"\n(e.g. HTML and LaTeX being much more complicated ones).\nThis website is also made with a file type that is a Markdown variant.\n\nBut because of Markdown's simplicity,\na Markdown file can look very similar to a plain text file.\nThe only Markdown features used in the README file are\nbackticks around file names, so they will show up in `code font`,\nand `#`, which will create a Level 1 header.\n:::\n\n<br>\n\n### `head` and `tail`\n\nThe twin commands `head` and `tail` will print the first and last lines,\nrespectively, of a file &mdash;\nthis can be very useful to preview the contents of larger files.\n\nBy default, `head` and `tail` will print up to 10 lines of a file:\n\n```bash\nhead metadata/meta.tsv\n```\n```{.bash-out}\nsample_id       cell_line       variant\nASPC1_A178V     ASPC1   A178V\nASPC1_A178V     ASPC1   A178V\nASPC1_G31V      ASPC1   G31V\nASPC1_G31V      ASPC1   G31V\nMiapaca2_A178V  Miapaca2        A178V\nMiapaca2_A178V  Miapaca2        A178V\nMiapaca2_G31V   Miapaca2        G31V\nMiapaca2_G31V   Miapaca2        G31V\n```\n\nBut `meta.tsv` only has 9 lines, so we got 9 instead.\nWe can use the `-n` argument to modify the number of lines that is being printed:\n\n```bash\ntail -n 3 metadata/meta.tsv\n```\n```{.bash-out}\nMiapaca2_A178V  Miapaca2        A178V\nMiapaca2_G31V   Miapaca2        G31V\nMiapaca2_G31V   Miapaca2        G31V\n```\n\n<br>\n\n### `less`\n\nAnother very handy command to view medium to large text files is `less`,\nwhich opens up a text file within your shell in a \"pager\".\nThat is, you will not get your prompt back until you press <kbd>q</kbd> to quit `less`,\nbut you can e.g. scroll/move around in the file.\n\nBesides scrolling with your mouse,\nits easiest to move around with  up and down arrows and,\nif you have them, <kbd>PgUp</kbd> and <kbd>PgDn</kbd> \n(also, <kbd>u</kbd> will move up half a page and <kbd>d</kbd> will move down\nhalf a page).\n\nIf you find yourself scrolling down and down to try and reach the end of the file,\nyou can instead press <kbd>G</kbd> to go to the very end right away\n(and <kbd>g</kbd> to go back to the top).\n\nTry it with one of the FASTQ files (we'll go into more detail next time!):\n\n```bash\nless data/fastq/ASPC1_A178V_R1.fastq.gz\n```\n\n<br>\n\n## Command output redirection\n\nAs mentioned earlier, Unix commands nearly always print their output to the screen.\nBut you can also **\"redirect\" the output** to a file or to another command.\n\n### Plain redirection with `>`\n\nWith \"**`>`**\", we redirect output to a file:\n\n- If the file doesn't exist, it will be *created*.\n- If the file does exist, any contents will be *overwritten*. \n  \n```bash\necho \"My first line\" > test.txt\n```\n```bash\ncat test.txt\n```\n```{.bash-out}\nMy first line\n```\n\nOf course, redirection works not just with `echo`, but with every single command\n(or bioinformatics program) that prints output to screen:\n\n```bash\nls > my_files_on_2023-08-04.txt\n```\n```bash\ncat my_files_on_2023-08-04.txt    # Use tab completion\n```\n```{.bash-out}\ndata\nmetadata\nmy_files_on_20230803.txt\nREADME.md\ntest.txt\n```\n\n<br>\n\n### Appending with `>>`\n\nWith \"**`>>`**\", we **append** the output to a file\n(that is, it won't overwrite any existing content like `>`):\n\n```bash\necho \"My second line\" >> test.txt\n```\n```bash\ncat test.txt\n```\n```{.bash-out}\nMy first line\nMy second line\n```\n\nAnd to circle back to `>`, demonstrating how this will overwrite contents:\n\n```bash\necho \"My third line overwrote the first two!\" > test.txt\n```\n```bash\ncat test.txt\n```\n```{.bash-out}\nMy third line overwrote the first two!\n```\n\n<br>\n\n### The pipe\n\nA third way of redirecting command output is quite different from the previous\ntwo &mdash;\nthe **`|` (pipe)** takes the output of one command and \"pipes\" it as input for\na subsequent command.\n\n```bash\n# This will tell us how many files and dirs are in our current working dir\nls -l | wc -l\n```\n```{.bash-out}\n6\n```\n\nIn the example above,\nthe output of the `ls` command (i.e., a list of files and dirs)\nwas not printed to screen but piped to the `wc -l` command,\nwhich then counted the number of lines in the input it received through the pipe.\n\nThis also reveals, then, that `wc` accepts input in two ways:\n\n1. One ore more files, whose names are passed as arguments (`wc -l README.md`)\n2. So-called \"standard input\", a \"stream\" of input directly passed to the command,\n   most commonly via the pipe (`cat README.md | wc -l`).\n\nAnd this is true not just for `wc`, but for almost any shell command that accepts\ninput data to operate on.\n\nPipes are incredibly useful because they avoid the need write/read intermediate files &mdash;\nthis saves typing and also makes the operation much quicker.\n\n<br>\n\n::: {.callout-tip}\n### The power of the Unix shell\n\nAnother example, where we combine shell wildcards with output redirection,\ndemonstrates how simple and powerful the Unix shell can be\n(and why the `cat` command is named after concatenation).\n\nImagine you had a thousand FASTA files in a dir `fastas`,\nand wanted to combine all of them, back-to-back, into a single file\n(\"multi-FASTA\" files, i.e. FASTA files with multiple sequences,\nindeed just consist of multiple FASTA entries concatenated).\nThis simple command would do that &mdash;\nand would be very fast even for really large files:\n\n```bash\n# (Fictitious example, you don't have a dir 'fastas')\ncat fastas/*.fa > combined.fa\n```\n\nImagine trying to create such a concatenated file in a regular text editor\nwith a graphical user interface!\n:::\n\n::: {.callout-warning collapse=\"true\"}\n#### \"Standard output\" vs \"standard error\" (Click to expand)\n\nWhile we have not noticed it so far,\nUnix commands &ndash;and many bioinformatics command-line tools alike&ndash;\nactually separate \"regular\" output (called \"**standard output**\") from\nerror messages (\"**standard error**\").\n\nWithout redirection, this is not obvious because both types of output are then\nprinted to screen.\nBut look what happens when we run `ls` with a non-existing file name as an\nargument, and redirect the output:\n\n```bash\nls -lh non_existent_file > my_file_list.txt\n```\n```{.bash-out}\nls: cannot access non_existent_file: No such file or directory\n```\n```bash\ncat my_file_list.txt\n```\n```{.bash-out}\n \n```\n\n**The error message (standard error) was _not_ redirected to the output file,**\nbut printed to the screen!\n\nOr consider this example:\n\n```bash\nls -lh README.md non_existent_file > another_file_list.txt\n```\n```{.bash-out}\nls: cannot access non_existent_file: No such file or directory\n```\n```bash\ncat another_file_list.txt\n```\n```{.bash-out}\n-rw-r--r-- 1 jelmer PAS0471 964 Jul 27 17:48 README.md\n```\n\nIn the example above,\nthe `ls` command produced both standard out\n(the successful file listing of `README.md`)\nand standard error\n(the error message for `non_existent_file`), and:\n\n- Standard output was redirected to the file\n- Standard error was printed to screen.\n\nOf course, there _is_ also a way to redirect standard error.\nWe'll at least see this in the context of standard out and standard error \nredirection for Slurm batch jobs.\n:::\n\n<br>\n\n## At-home reading: reference pages {-}\n\n- [Common shell commands](../info/shell_commands.qmd)\n- [Shell keyboard shortcuts](../info/shell_shortcuts.qmd)\n\n<br>\n\n## Further resources {-}\n\n- [OSC's UNIX Basics](https://www.osc.edu/documentation/tutorials/unix_basics)\n- <https://www.learnenough.com/command-line-tutorial>\n- <https://cvw.cac.cornell.edu/Linux/>\n- <http://www.ee.surrey.ac.uk/Teaching/Unix/>\n- <https://www.udacity.com/course/linux-command-line-basics--ud595>\n- <http://moo.nac.uci.edu/~hjm/How_Programs_Work_On_Linux.html>\n\n<br> <br>\n",
    "supporting": [
      "A04_shell2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}