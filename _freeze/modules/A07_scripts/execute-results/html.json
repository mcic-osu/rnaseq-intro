{
  "hash": "95db5b8add001a6b076a786b1969a49d",
  "result": {
    "markdown": "---\ntitle: \"Shell Scripting\"\npagetitle: \"Shell Scripting\"\nhighlight-style: github\nnumber-sections: true\nengine: knitr\nauthor: Jelmer Poelstra\ndate: 2023-09-01\n---\n\n::: {.cell}\n\n:::\n\n\n-------\n\n<br>\n\n## Overview & Getting started\n\nShell scripts enable us to **run sets of commands non-interactively**,\nwhich is useful:\n\n- When a set of commands takes a long time to run and/or should be run many times.\n\n- To help keep our code clean and clear by using separate scripts for individual\n  parts of our analysis pipeline.\n\n- To run our analyses as Slurm batch jobs at OSC,\n  (which will for instance to allow them to run simultaneously for differet samples)\n\nScripts form the basis for *analysis pipelines* and if we code things cleverly,\nit should be **straightforward to rerun much of our project workflow**\nafter removing or adding some samples, with different parameter settings,\nand possibly even for an entirely different dataset. \n\n<br>\n\n### Start VS Code and open your folder {-}\n\nAs always, we'll be working in VS Code &mdash;\nif you don't already have a session open, see below how to do so.\n\n**Make sure to open your `/fs/ess/PAS0471/<user>/rnaseq_intro` dir**,\neither by using the `Open Folder` menu item,\nor by clicking on this dir when it appears in the `Welcome` tab.\n\n:::{.callout-tip collapse=\"true\"}\n## Starting VS Code at OSC - with a Terminal (Click to expand)\n1. Log in to OSC's OnDemand portal at <https://ondemand.osc.edu>.\n\n2. In the blue top bar, select `Interactive Apps`\n   and then near the bottom of the dropdown menu, click `Code Server`.\n\n3. In the form that appears on a new page:\n   - Select an appropriate OSC project (here: `PAS0471`)\n   - For this session, select `/fs/ess/PAS0471` as the starting directory\n   - Make sure that `Number of hours` is at least `2`\n   - Click `Launch`.\n\n4. On the next page, once the top bar of the box has turned green\n   and says `Runnning`, click `Connect to VS Code`.\n\n<figure><p align=\"center\"><img src=img/osc-code-launch_ed.png width=\"80%\"></p></figure>\n\n5. Open a Terminal by clicking\n   &nbsp; {{< fa bars >}} &nbsp; => `Terminal` => `New Terminal`.\n   (Or use one of the keyboard shortcuts:\n   <kbd>Ctrl</kbd>+<kbd>\\`</kbd> (backtick) or\n   <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>C</kbd>.)\n\n6. In the `Welcome` tab under `Recent`,\n   you should see your `/fs/ess/PAS0471/<user>/rnaseq_intro` dir listed:\n   click on that to open it.\n   Alternatively, use\n   &nbsp; {{< fa bars >}} &nbsp; => &nbsp; `File` &nbsp; => &nbsp; `Open Folder`\n   to open that dir in VS Code.\n:::\n\n:::{.callout-warning collapse=\"true\"}\n#### Don't have your own dir with the data? (Click to expand)\nIf you missed the last session, or deleted your `rnaseq_intro` dir entirely,\nrun these commands to get a (fresh) copy of all files you should have so far:\n\n```bash\nmkdir -p /fs/ess/PAS0471/$USER/rnaseq_intro\ncp -r /fs/ess/PAS0471/demo/202307_rnaseq /fs/ess/PAS0471/$USER/rnaseq_intro\n```\n\nAnd if you do have an `rnaseq_intro` dir,\nbut you want to start over because you moved or removed some of the files\nwhile practicing, then delete the dir before your run the commands above:\n\n```bash\nrm -r /fs/ess/PAS0471/$USER/rnaseq_intro\n```\n\nYou should have at least the following files in this dir:\n\n```{.bash-out}\n/fs/ess/PAS0471/demo/202307_rnaseq\n├── data\n│   └── fastq\n│       ├── ASPC1_A178V_R1.fastq.gz\n│       ├── ASPC1_A178V_R2.fastq.gz\n│       ├── ASPC1_G31V_R1.fastq.gz\n│       ├── ASPC1_G31V_R2.fastq.gz\n│       ├── md5sums.txt\n│       ├── Miapaca2_A178V_R1.fastq.gz\n│       ├── Miapaca2_A178V_R2.fastq.gz\n│       ├── Miapaca2_G31V_R1.fastq.gz\n│       └── Miapaca2_G31V_R2.fastq.gz\n├── metadata\n│   └── meta.tsv\n└── README.md\n│   └── ref\n│       ├── GCF_000001405.40.fna\n│       ├── GCF_000001405.40.gtf\n```\n:::\n\n<br>\n\n## A basic shell script\n\n### Our first script\n\nWe'll be writing our shell scripts in the editor pane of VS Code.\nTo create our first one, open a new file in the `VS Code` editor\n(&nbsp; {{< fa bars >}} &nbsp; => &nbsp; `File` &nbsp; => &nbsp; `New File`)\nand save it as `printname.sh` within the `sandbox` dir\n(shell scripts most commonly have the extension `.sh`).\n\nThen, type or paste the following _inside the script_ in your editor pane\n(and _not_ in the terminal pane):\n\n```bash\necho \"This script will print a first and a last name\"\n```\n\n::: {.callout-tip}\n#### Auto Save\n\nThe changes to the file should be immediately, automatically saved by VS Code:\nif that's not happening for some reason,\nthere should be an indication like a large black dot next to the script's file\nname in the editor pane tab header (see the box below how to fix this).\n\n::: {.callout-warning collapse=\"true\"}\n### Auto Save not happening? (Click to expand)\n\nIf the file is not auto-saving, you can always save it manually\n(including with <kbd>Ctrl/Cmd</kbd>+<kbd>S</kbd>)\nlike you'd do in other programs.\n\nHowever, it may be convenient to turn Auto Save on:\npress <kbd>Ctrl/Cmd</kbd>+<kbd>Shift</kbd>+<kbd>S</kbd>\nto open the Command Palette and type \"Auto Save\".\nYou should see an option \"Toggle Auto Save\": click on that.\n:::\n:::\n\nShell scripts mostly contain the same regular Unix shell (specifically, Bash shell)\ncode that we have so far just been typing in the terminal.\nAs such,\n**our single line with an `echo` command already consitutes a functional shell script!**\nOne way of running the script is by calling the `bash` command followed by the\nname of the script:\n\n```bash\nbash sandbox/printname.sh\n```\n```{.bash-out}\nThis script will print a first and a last name\n```\n\nThat worked! \nAlthough of course,\nthe script doesn't yet print your name like it \"promises\" to do,\nbut we will add that functionality in a little bit.\n\nFirst, though, we'll learn about two header lines that are good practice to\nadd to every shell script.\n\n<br>\n\n### Shebang line\n\nWe use a so-called \"_shebang_\" line as the first line of a script\nto **indicate which language our script uses**.\nMore specifically, this line tell the computer where to find the binary\n(executable) that will run our script.\n  \nSuch a line starts with **`#!`**,\nbasically marking it as a special type of comment.\nAfter that, we provide the location to the relevant program:\nin our case Bash (which is the specific type of shell we are using),\nwhich is located at `/bin/bash` on Linux and Mac computers.\n\n```sh\n#!/bin/bash\n```\n\nWhile not always strictly necessary, adding a shebang line is good practice,\nespecially when we want to submit our script to OSC's Slurm queue.\n\n<br>\n\n### Shell script settings\n\nAnother line that is good practice to add to your shell scripts changes some\ndefault settings to safer alternatives.\n\n#### Bad default shell settings {-}\n\nThe following two default settings of the Bash shell are bad ideas inside scripts:\n\n**_First_**, as we've seen previously,\nwhen you **reference a variable that does not exist**,\nthe shell will just replace that with nothing, and will not complain:\n\n```bash\necho \"Hello, my name is $myname ...\"\n```\n```{.bash-out}\nHello, my name is  ...\n```\n\nIn scripts, this can lead to all sorts of downstream problems,\nbecause you very likely tried and failed to do something with an existing variable\n(but misspelled its name, or forgot to assign it altogether).\nEven more problematically,\nit can lead to potentially very destructive file removal:\n\n```bash\n# Using a variable, we try to remove some temporary files whose names start with tmp_\ntemp_prefix=\"temp_\"\nrm \"$tmp_prefix\"*     # DON'T TRY THIS!\n```\n\n```bash\n# Using a variable, we try to remove a temporary directory\ntempdir=output/tmp\nrm -rf $tmpdir/*      # DON'T TRY THIS!\n```\n\n:::{.callout-caution collapse=\"true\"}\n## The comments above specified the _intent_ we had. What would have actually happened?\n  \nIn both examples, there is a similar typo: `temp` vs. `tmp`,\nwhich means that we are referencing a (likely) non-existent variable.\n\n- In the first example,\n  `rm \"$tmp_prefix\"*` would have been interpreted as `rm *`,\n  because the non-existent variable is simply ignored.\n  Therefore, we would have **removed all files in the current working directory**.\n\n- In the second example, along similar lines,\n  `rm -rf $tmpdir/*` would have been interpreted as `rm -rf /*`.\n  Horrifyingly, this would **attempt to remove the entire filesystem**:\n  recall that a leading `/` in a path is a computer's root directory[^1].\n  (`-r` makes the removal _recursive_ and `-f` makes _forces_ removal).\n\n[^1]: But note that at OSC,\nyou would not be able to remove anything you're not supposed to,\nsince you don't have the permissions to do so.\nOn your own computer, this could be more genuinely dangerous, though even there,\nyou would not be able to remove the operating system without specifically\nrequesting  \"admin\" rights.\n\n:::\n\n**_Second_**, a Bash script **keeps running after encountering errors**.\nThat is, if an error is encountered when running, say, line 2 of a script,\nany remaining lines in the script will nevertheless be executed.\n\nIn the best case, this is a waste of computer resources,\nand in worse cases, it can lead to all kinds of unintended consequences.\nAdditionally, if your script prints a lot of output,\nyou might not notice an error somewhere in the middle if it doesn't produce\nmore errors downstream.\nBut the downstream results from what we at that point might call a\n\"**zombie script**\" may still be completely wrong.\n\n#### Safer settings {-}\n\nThe following three settings will make your Bash scripts more robust and safer.\nWith these settings, the script terminates,\nwith an appropriate error message, if:\n\n- `set -u` &mdash; An unset (non-existent) variable is referenced.\n- `set -e` &mdash; Almost any error occurs.\n- `set -o pipefail` &mdash; An error occurs in a shell \"pipeline\"\n  (e.g., `sort | uniq`).\n\nWe can change all of these settings in one line in a script:\n\n```bash\nset -e -u -o pipefail     # (For in a script - don't run in the terminal)\n```\n\nOr even more concisely:\n\n```bash\nset -euo pipefail         # (For in a script - don't run in the terminal)\n```\n\n<br>\n\n### Adding the header lines to our script\n\nLet's add these lines to our `headtail.sh` script,\nso it will now contain the following:\n\n```bash\n#!/bin/bash\nset -ueo pipefail\n\necho \"This script will print a first and a last name\"\n```\n  \nAnd let's run it again:\n\n```bash\nbash sandbox/printname.sh\n```\n```{.bash-out}\nThis script will print a first and a last name\n```\n\nThat didn't change anything to the output,\nbut at least we confirmed that the script still works.\n\n::: {.callout-note collapse=\"true\"}\n#### Running the script without using `bash` (Click to expand)\n\nBecause our script has a shebang line,\nwe could also execute the script without the `bash` command,\nsimply using `sandbox/printname.sh`.\n\n(Or if the script was in our current working dir, using `./printname.sh`.\nIn that case the `./` is necessary to make it explicit that we are referring\nto a file name:\notherwise, when running just `printname.sh`,\nthe shell would look for a command or program of that name,\nand wouldn't be able to find it.)\n\nHowever, this would also require us to \"make the script executable\",\nwhich is beyond the scope of this workshop.\n\n:::\n\n<br>\n\n## Command-line arguments for scripts\n\n### Calling a script with arguments\n\nWhen you call a script, you can pass it command-line arguments,\nsuch as a file to operate on.\n\nThis is much like when you provide a command like `ls` with arguments:\n\n```bash\n# Run ls without arguments:\nls\n\n# Pass 1 filename as an argument to ls:\nls data/sampleA.fastq.gz\n\n# Pass 2 filenames as arguments to ls, separated by spaces:\nls data/sampleA.fastq.gz data/sampleB.fastq.gz\n```\n\nLet's see what this would look like with our `printname.sh` script\nand a fictional script `fastqc.sh`:\n\n```bash\n# Run scripts without any arguments:\nbash fastqc.sh                            # (Fictional script)\nbash sandbox/printname.sh\n\n# Run scripts with 1 or 2 arguments:\nbash fastqc.sh data/sampleA.fastq.gz      # 1 argument, a filename\nbash sandbox/printname.sh John Doe        # 2 arguments, strings representing names\n```\n\nIn the next section, we'll see what happens when we pass arguments to a script\non the command line.\n\n<br>\n\n### Placeholder variables\n\nInside the script,\nany command-line arguments that you passed to it are _automatically available_\nin placeholder variables.\n\nA first argument will be assigned to the variable **`$1`**,\nany second argument will be assigned to **`$2`**,\nany third argument will be assigned to **`$3`**, and so on.\n\n:::{.callout-caution collapse=\"true\"}\n## In the calls to fastqc.sh and printname.sh above, what are the placeholder variables and their values? \n\nIn `bash fastqc.sh data/sampleA.fastq.gz`,\na single argument, `data/sampleA.fastq.gz`, is passed to the script,\nand will be assigned to `$1`.\n\nIn `bash sandbox/printname.sh John Doe`,\ntwo arguments are passed to the script:\nthe first one (`John`) will be stored in `$1`,\nand the second one (`Doe`) in `$2`.\n:::\n\n:::{.callout-tip}\n## Placeholder variables are not automagically _used_\nArguments passed to a script are _merely made available_ in placeholder variables\n&mdash; unless we explicitly include code in the script to _do_ something with\nthose variables, nothing else happens. \n:::\n\nLet's add code to our `printname.sh` script to \"process\"\nany first and last name that are passed to the script as command-line arguments.\nFor now, our script will simply `echo` the placeholder variables,\nso that we can see what happens:\n\n```bash\n#!/bin/bash\nset -ueo pipefail\n\necho \"First name: $1\"\necho \"Last name: $2\"\n\n# (Note: this is a script. Don't enter this directly in your terminal.)\n```\n\nNext, we'll _run_ the script, passing the arguments `John` and `Doe`:\n\n```bash\nbash sandbox/printname.sh John Doe\n```\n```{.bash-out}\nFirst name: John\nLast name: Doe\n```\n\n:::{.exercise}\n### On Your Own: Command-line arguments {-}\n\nIn each case below, **think about what might happen before you run the script**.\nThen, run it, and if you didn't make a successful prediction,\ntry to figure out what happened instead.\n\n1. Run the script (`sandbox/printname.sh`) without passing arguments to it.\n\n2. Deactivate (\"comment out\") the line with `set` settings\n   by inserting a `#` as the first character.\n   Then, run the script again without passing arguments to it.\n\n3. Double-quote `John Doe` when you run the script,\n   i.e. run `bash sandbox/printname.sh \"John Doe\"`\n\nTo get back to where we were,\nremove the `#` you inserted in the script in step 2 above.\n\n:::{.callout-tip collapse=\"true\"}\n## Solutions\n\n1. The script will error out because we are referencing variables that don't\n   exist: since we didn't pass command-line arguments to the script,\n   the `$1` and `$2` have not been set.\n\n```bash\nbash sandbox/printname.sh\n```\n\n:::{.bash-out}\nprintname.sh: line 4: $1: unbound variable\n:::\n\n2. The script will run in its entirety and not throw any errors,\n   because we are now using default Bash settings such that referencing \n   non-existent variables does not throw an error.\n   Of course, no names are printed either, since we didn't specify any:\n\n```bash\nbash sandbox/printname.sh\n```\n```{.bash-out}\necho \"First name:\"\necho \"Last name:\"\n```\n\nBeing commented out, the `set` line should read:\n\n```bash\n#set -ueo pipefail\n```\n\n3. Because we are quoting `\"John Doe\"`,\n   both names are passed _as a single argument_ and both names end up in `$1`,\n   the \"first name\":\n\n```bash\nbash sandbox/printname.sh \"John Doe\"\n```\n```{.bash-out}\necho \"First name: John Doe\"\necho \"Last name:\"\n```\n\n:::\n:::\n\n<br>\n\n### Copying placeholders to variables with descriptive names\n\nWhile you can use the `$1`-style placeholder variables throughout your script,\nI find it very useful to copy them to more descriptively named variables\nas follows:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n#!/bin/bash\nset -ueo pipefail\n\nfirst_name=$1\nlast_name=$2\n  \necho \"First name: $first_name\"\necho \"Last name: $last_name\"\n\n# (Note: this is a script. Don't enter this directly in your terminal.)\n```\n:::\n\n\nUsing descriptively named variables in your scripts has several advantages.\nIt will make your script easier to understand for others and for yourself.\nIt will also make it less likely that you make errors in your script\nin which you use the wrong variable in the wrong place.\n\n:::{.callout-note}\n## Other variables that are automatically available inside scripts\n\n- `$0` contains the script's file name\n- `$#` contains the _number_ of command-line arguments passed to the script\n:::\n\n:::{.exercise}\n\n### On Your Own: A script to print a specific line {-}\n\nWrite a script that prints a specific line (identified by line number)\nfrom a file.\n\n- Open a new file and save it as `sandbox/printline.sh`\n- Start with the _shebang_ and `set` lines\n- Your script takes two arguments: a file name (`$1`) and a line number (`$2`) \n- Copy the `$1` and `$2` variables to descriptively named variables\n- To print a specific line,\n  think how you might combine `head` and `tail` to do this.\n  If you're at a loss, feel free to check out the top solution box.\n- Test the script by printing line 4 from `metadata/meta.tsv`.\n\n:::{.callout-tip collapse=\"true\"}\n## Solution: how to print a specific line number (Click to expand)\n\nFor example, to print line 4 of `metadata/meta.tsv` directly:\n\n```bash\nhead -n 4 metadata/meta.tsv | tail -n 1\n```\n\nHow this command works:\n\n- `head -n 4 metadata/meta.tsv` will print the first 4 lines of `metadata/meta.tsv`\n- We pipe those 4 lines into the `tail` command\n- We ask `tail` to just print the last line of its input,\n  which will in this case be line 4 of the original input file.\n:::\n\n:::{.callout-tip collapse=\"true\"}\n## Full solution (Click to expand)\n\n```bash\n#!/bin/bash\nset -ueo pipefail\n  \ninput_file=$1\nline_nr=$2\n\nhead -n \"$line_nr\" \"$input_file\" | tail -n 1\n```\n\nTo run the script and make it print the 4th line of `meta.tsv`:\n\n```bash\nbash sandbox/printline.sh metadata/meta.tsv 4\n```\n```{.bash-out}\nASPC1_G31V      ASPC1   G31V\n```\n:::\n:::\n\n<br>\n\n## Script variations and enhancements\n\nIn this section,\nwe will change our `printline.sh` script and a similar small utility script\nto **make their behavior more like scripts that run a bioinformatics program**:\nthe script's _main output will end up in a file_,\nbut it prints extensive \"logging\" notes to the screen,\nso we can monitor what we're doing.\n\n### A script to serve as a starting point\n\nWe've learned that the `head` command prints the first lines of a file,\nwhereas the `tail` command prints the last lines.\nSometimes it's nice to be able to quickly see both ends of a file,\nso let's write a little script that can do that for us,\nas a starting point for the next few modifications.\n\nOpen a new file, save it as `sandbox/headtail.sh`,\nand add the following code to it:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n#!/bin/bash\nset -ueo pipefail\n\ninput_file=$1\n\nhead -n 2 \"$input_file\"\necho \"---\"\ntail -n 2 \"$input_file\"\n\n# (Note: this is a script. Don't enter this directly in your terminal.)\n```\n:::\n\n\nNext, let's run our `headtail.sh` script:\n\n```bash\nbash sandbox/headtail.sh metadata/meta.tsv\n```\n```{.bash-out}\nsample_id       cell_line       variant\nASPC1_A178V     ASPC1   A178V\n---\nMiapaca2_G31V   Miapaca2        G31V\nMiapaca2_G31V   Miapaca2        G31V\n```\n\n<br>\n\n### Redirecting output to a file\n\nSo far, the output of our scripts was printed to screen, e.g.:\n\n- In `printname.sh`, we simply `echo`'d, inside sentences,\n  the arguments passed to the script.\n- In `headtail.sh`, we printed the first and last few lines of a file.\n\nAll this output was printed to screen because that is the default output\nmode of Unix commands,\nand this works the same way regardless of whether those commands\nare typed and run interactively in the shell, or are run inside a script.\n\nAlong those same lines, we have already learned that we can \"redirect\" output\nto a file using `>` (write/overwrite) and `>>` (append) when we run shell commands &mdash; and this, too, works exactly the same way inside a script.\n\n-----\n\nWhen working with genomics data,\nwe commonly have **files as input, and new/modified files as output**.\nLet's practice with this and\n_modify our `headtail.sh` script so that it writes output to a file._\n\nWe'll make the following changes:\n\n- We will have the script accept a second argument: the output file name[^8].\n  \n- We will redirect the output of our `head`, `echo`, and `tail` commands to\n  the output file. We'll have to append (using `>>`) in the last two commands.\n\n[^8]: Of course, we _could_ also simply write the output to a predefined\n      (\"hardcoded\") file name such as `out.txt`,\n      but in general, it's better practice to keep this flexible via an argument.\n  \n```bash\n#!/bin/bash\nset -ueo pipefail\n\ninput_file=$1\noutput_file=$2\n\nhead -n 2 \"$input_file\" > \"$output_file\"\necho \"---\" >> \"$output_file\"\ntail -n 2 \"$input_file\" >> \"$output_file\"\n\n# (Note: this is a script. Don't enter this directly in your terminal.)\n```\n\nNow we run the script again, this time also passing the name of an _output_ file:\n\n```bash\nbash sandbox/headtail.sh metadata/meta.tsv sandbox/samples_headtail.txt\n```\n\nThe script will no longer print any output to screen,\nand our output should instead be in `sandbox/samples_headtail.txt`:\n\n```bash\n# Check that the file exists and was just modified:\nls -lh sandbox/samples_headtail.txt\n```\n```{.bash-out}\n-rw-r--r-- 1 jelmer PAS0471 112 Aug 16 16:45 sandbox/samples_headtail.txt\n```\n\n```bash\n# Print the contents of the file to screen\ncat sandbox/samples_headtail.txt\n```\n```{.bash-out}\nsample_id       cell_line       variant\nASPC1_A178V     ASPC1   A178V\n---\nMiapaca2_G31V   Miapaca2        G31V\nMiapaca2_G31V   Miapaca2        G31V\n```\n\n<br>\n\n### Report what's happening\n\nIt is often useful to have your scripts \"report\" or \"log\" what is going on.\nLet's keep thinking about a script that has one or more files as its main output\n(again, like most bioinformatics programs do).\nBut instead of having no output printed to screen at all,\nwe'll print some logging output to screen.\nFor instance:\n\n- At what date and time did we run this script \n- Which arguments were passed to the script\n- What are the output files\n- Perhaps even summaries of the output.\n\nAll of this can help with troubleshooting and record-keeping[^3].\nLet's try this with our `headtail.sh` script.\n\n[^3]: We'll see in the upcoming Slurm module that we when\n      submit scripts to the OSC queue (rather than running them directly),\n      the output of scripts that is normally printed to screen,\n      will instead go to a sort of \"log\" file.\n      So, your script's reporting will end up in this file.\n\n```bash\n#!/bin/bash\nset -ueo pipefail\n\n# Copy placeholder variables\ninput_file=$1\noutput_file=$2\n\n# Initial logging \necho \"# Starting script headtail.sh\" # Print name of script\ndate                                 # Print date & time\necho \"# Input file:   $input_file\"\necho \"# Output file:  $output_file\" \necho                                 # Empty line to separate initial & final logging\n\n# Print the first and last two lines to a separate file\nhead -n 2 \"$input_file\" > \"$output_file\"\necho \"---\" >> \"$output_file\"\ntail -n 2 \"$input_file\" >> \"$output_file\"\n\n# Final logging\necho \"# Listing the output file:\"\nls -lh \"$output_file\"\necho \"# Done with script headtail.sh\"\ndate\n\n# (Note: this is a script. Don't enter this directly in your terminal.)\n```\n\nA couple of notes about the lines that were added to the script above:\n\n- Running `date` at the end of the script (as well as at the beginning)\n  allows you to check for how long the script ran\n  \n- Printing the input and output files\n  (and the command-line arguments more generally)\n  can be particularly useful for troubleshooting\n\n- We printed a \"marker line\" like `Done with script`,\n  indicating that the end of the script was reached.\n  This is handy due to our `set` settings:\n  **seeing this line printed means that no errors were encountered**.\n\n- I also added some comment lines like \"Initial logging\" to make the script\n  easier to read, and such comments can be made more extensive to really explain\n  what is being done.\n\nLet's run the script again:\n\n```bash\nbash sandbox/headtail.sh metadata/meta.tsv sandbox/tmp.txt\n```\n```{.bash-out}\n# Starting script sandbox/headtail.sh\nWed Aug 16 21:12:28 EDT 2023\n# Input file:   metadata/meta.tsv\n# Output file:  sandbox/tmp.txt\n\n# Listing the output file:\n-rw-r--r-- 1 jelmer PAS0471 112 Aug 16 21:12 sandbox/tmp.txt\n# Done with script sandbox/headtail.sh\nWed Aug 16 21:12:28 EDT 2023\n```\n\nThe script printed some details for the output file,\nbut not its contents\n(that would have worked here,\nbut is usually not sensible when working with genomics data).\nLet's take a look at the output file, though, to make sure the script worked:\n\n```bash\ncat sandbox/tmp.txt\n```\n```{.bash-out}\nsample_id       cell_line       variant\nASPC1_A178V     ASPC1   A178V\n---\nMiapaca2_G31V   Miapaca2        G31V\nMiapaca2_G31V   Miapaca2        G31V\n```\n\n:::{.callout-tip}\n## `echo`, `echo`?\nThe extensive logging output (`echo` statements)\nmay seem silly for our little `headtail.sh` script,\nand it is at some level:\na tiny utility script like this would ideally work much like a regular Unix\nshell command, and just print the main output and no logging output.\n\nHowever, this kind of fairly extensive logging is in fact useful when running\nscripts that execute long-running bioinformatics programs,\nand can eventually be a time-saver because it makes it easier to spot problems\nand helps with record-keeping.\nThis is especially true for long-running scripts,\nor scripts that you often reuse and perhaps share with others.\n:::\n\n:::{.exercise}\n### On Your Own: A fanciful script {-}\nModify your `printline.sh` script to:\n\n- Redirect the main output (the printed line) to a file\n- The name of this output file should not be \"hardcoded\" in the script,\n  but should be passed as an argument to the script,\n  like we did above with `headtail.sh`\n- Add a bit of logging &mdash; `echo` statements, `date`, etc,\n  similar to what we did above with `headtail.sh`\n- Add some comments to describe what the code in the script is doing\n\n:::{.callout-note collapse=\"true\"}\n## The original `printline.sh` script (Click to expand)\n\n```bash\ncat sandbox/printline.sh\n```\n```{.bash-out}\n#!/bin/bash\nset -ueo pipefail\n  \ninput_file=$1\nline_nr=$2\n\nhead -n \"$line_nr\" \"$input_file\" | tail -n 1\n```\n:::\n\n:::{.callout-tip collapse=\"true\"}\n## (One possible) solution  (Click to expand)\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n#!/bin/bash\nset -ueo pipefail\n\n# Copy placeholder variables\ninput_file=$1\noutput_file=$2\nline_nr=$3\n\n# Initial logging \necho \"# Starting script printline.sh\"\ndate\necho \"# Input file:   $input_file\"\necho \"# Output file:  $output_file\"\necho \"# Line number:  $line_nr\"\necho\n\n# Print 1 specific line from the input file and redirect to an output file\nhead -n \"$line_nr\" \"$input_file\" | tail -n 1 > $output_file\n\n# Final logging\necho \"# Listing the output file:\"\nls -lh \"$output_file\"\necho \"# Done with script printline.sh\"\ndate\n```\n:::\n\n\nTo run the script with the additional argument:\n\n```bash\nbash sandbox/printline.sh metadata/meta.tsv sandbox/meta_line.tsv 4\n```\n```{.bash-out}\n# Starting script printline.sh\nWed Aug 16 21:27:48 EDT 2023\n# Input file:   metadata/meta.tsv\n# Output file:  sandbox/meta_line.tsv\n# Line number:  4\n\n# Listing the output file:\n-rw-r--r-- 1 jelmer PAS0471 22 Aug 16 21:27 sandbox/meta_line.tsv\n# Done with script printline.sh\nWed Aug 16 21:27:48 EDT 2023\n```\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}